var documenterSearchIndex = {"docs":
[{"location":"#Quasi-Monte-Carlo-Generators","page":"Home","title":"Quasi-Monte Carlo Generators","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julia version of Dirk Nuyens' Magic Point Shop. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the Tutorial for instructions on how to use this package.  ","category":"page"},{"location":"#Quasi-Random-Generators","page":"Home","title":"Quasi-Random Generators","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"QMCGenerators.jl implements quasi-random (low discrepancy) sequence generators. Quasi-random points are carefully coordinated in a dependent manner to more evenly fill 01^s compared to pseudo-random (independent) points. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package implements two flavors of quasi-random sequences: Lattice rules and digital nets, both in base 2. Independent randomizations may be applied to base sequences via random shifts for Lattices and random digital shifts for digital nets.  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: image)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Notice the gaps and clusters of the above pseudo-random points compared to the more even coverage of quasi-random points. The implemented quasi-random sequences are extensible, meaning you may increase the sample size through powers of two to better fill the space. Above, each plot starts with 2^6 purple points. Doubling the sample size to 2^7 adds the green points. Doubling again to 2^8 samples adds the blue points. ","category":"page"},{"location":"#Quasi-Monte-Carlo","page":"Home","title":"Quasi-Monte Carlo","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Monte Carlo methods approximate the true mean","category":"page"},{"location":"","page":"Home","title":"Home","text":"mu = mathbbEf(X) = int_01^s f(x) mathrmd x","category":"page"},{"location":"","page":"Home","title":"Home","text":"for f 01^s to mathbbR and X sim mathcalU01^s by the sample mean","category":"page"},{"location":"","page":"Home","title":"Home","text":"hatmu = frac1n sum_i=0^n-1 f(X_i)","category":"page"},{"location":"","page":"Home","title":"Home","text":"where X_0X_1dots sim mathcalU01^s. If X_i are chosen to be pseudo-random, then the sample average is a Simple Monte Carlo approximation with error mathcalO(n^-12). If instead we choose X_i to be quasi-random then the sample average is a Quasi-Monte Carlo approximation with error approaching mathcalO(n^-1). ","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: image)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The above example approximates mu = mathbbEg(T) where g mathbbR^s to mathbbR is the Keister function ","category":"page"},{"location":"","page":"Home","title":"Home","text":"g(t) = pi^s2 cos( lVert t rVert_2)","category":"page"},{"location":"","page":"Home","title":"Home","text":"and T sim mathcalN(0I_s2)  in dimension s=7. To make this Quasi-Monte Carlo compatible, we set ","category":"page"},{"location":"","page":"Home","title":"Home","text":"f(x) = g(Phi^-1(x)sqrt2)","category":"page"},{"location":"","page":"Home","title":"Home","text":"where Phi^-1 is the inverse CDF of mathcalN(01) applied elementwise. This transform satisfies","category":"page"},{"location":"","page":"Home","title":"Home","text":"mu = mathbbEf(X) = mathbbEg(T)","category":"page"},{"location":"","page":"Home","title":"Home","text":"where X sim mathcalU01^s as desired. ","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Kuo, F. Y., & Nuyens, D. (2016). Application of quasi-Monte Carlo methods to elliptic PDEs with random diffusion coefficients: a survey of analysis and implementation. Foundations of Computational Mathematics, 16, 1631-1696.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"DocTestSetup = quote\n    using QMCGenerators\nend","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Pages = [\"tutorial.md\"]\nDepth = 4","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To begin, install this package with ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Pkg.add(\"QMCGenerators\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"and then import via","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using QMCGenerators","category":"page"},{"location":"tutorial/#Common-Usage","page":"Tutorial","title":"Common Usage","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Often we just want to generate a single randomized quasi-random sequence. For example, to generate the first 4 points of a 3 dimensional digital net with 1 random digital shift with seed 7","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Next(RandomDigitalShift(DigitalSeqB2G(3),1,7),4)\n# output\n4×3 Matrix{Float64}:\n 0.648627  0.0158008  0.971646\n 0.148627  0.515801   0.471646\n 0.398627  0.265801   0.721646\n 0.898627  0.765801   0.221646","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"A similar API is available for randomly shifted Lattices:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Next(RandomShift(LatticeSeqB2(3),1,7),4)\n# output\n4×3 Matrix{Float64}:\n 0.812439   0.654977  0.489613\n 0.312439   0.154977  0.989613\n 0.0624386  0.404977  0.239613\n 0.562439   0.904977  0.739613","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"warning: Warning\nWhile not strictly enforced, sample sizes should be powers of two to achieve full coverage of 01^s","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In the following sections we always supply a seed for reproducibility. Supplying a seed requires you also supply the number of randomizations as done above. However, if you do not wish to seed, you can simply supply the number of randomizations. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"rls = RandomDigitalShift(DigitalSeqB2G(12),2)\nxs = NextR(rls,2^7)\nsize(xs)\n# output\n(2,)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"size(xs[1]) == size(xs[2]) == (2^7,12)\n# output\ntrue","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Moreover, you may use only one randomization without a seed with the simplified API","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"rls = RandomDigitalShift(DigitalSeqB2G(52))\nx = Next(rls,2^14)\nsize(x)\n# output\n(16384, 52)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The same API simplifications holds for Lattices. ","category":"page"},{"location":"tutorial/#Structure-and-Functions","page":"Tutorial","title":"Structure and Functions","text":"","category":"section"},{"location":"tutorial/#Unrandomized-Sequences","page":"Tutorial","title":"Unrandomized Sequences","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"warning: Warning\nIt is highly recommended you randomize sequences. The first point of an unrandomized sequence is 0 in 01^s which will be transformed to an infinite values in many functions e.g. those composed with taking the inverse CDF of a mathcalN(01) as done in the section on Quasi-Monte Carlo. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's start by defining a 5 dimensional (unrandomized) digital sequence and generating the first 4 points.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"ds = DigitalSeqB2G(5)\nNext(ds,4)\n# output\n4×5 Matrix{Float64}:\n 0.0   0.0   0.0   0.0   0.0\n 0.5   0.5   0.5   0.5   0.5\n 0.75  0.25  0.25  0.25  0.75\n 0.25  0.75  0.75  0.75  0.25","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can then generate the next 4 points in the sequence with ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Next(ds,4)\n# output\n4×5 Matrix{Float64}:\n 0.375  0.375  0.625  0.875  0.375\n 0.875  0.875  0.125  0.375  0.875\n 0.625  0.125  0.875  0.625  0.625\n 0.125  0.625  0.375  0.125  0.125","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To reset the generator use","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Reset!(ds)\nNext(ds,4)\n# output\n4×5 Matrix{Float64}:\n 0.0   0.0   0.0   0.0   0.0\n 0.5   0.5   0.5   0.5   0.5\n 0.75  0.25  0.25  0.25  0.75\n 0.25  0.75  0.75  0.75  0.25","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's reset once more before continuing ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Reset!(ds)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"These functions can also be applied to Lattices ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"ls = LatticeSeqB2(5)\nNext(ls,4)\n# output\n4×5 Matrix{Float64}:\n 0.0   0.0   0.0   0.0   0.0\n 0.5   0.5   0.5   0.5   0.5\n 0.25  0.75  0.75  0.25  0.25\n 0.75  0.25  0.25  0.75  0.75","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Next(ls,4)\n# output\n4×5 Matrix{Float64}:\n 0.125  0.375  0.375  0.125  0.125\n 0.625  0.875  0.875  0.625  0.625\n 0.375  0.125  0.125  0.375  0.375\n 0.875  0.625  0.625  0.875  0.875","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Reset!(ls)","category":"page"},{"location":"tutorial/#Independent-Sequence-Randomizations","page":"Tutorial","title":"Independent Sequence Randomizations","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Getting a single randomization was shown in the Common Usage section. Support is also available for multiple independent randomizations. For instance, we can generating 2 independent randomizations with seed 11 and get the next 4 points in each sequence via  ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"rds = RandomDigitalShift(ds,2,11)\nxs = NextR(rds,4)\ntypeof(xs)\n# output\nVector{Matrix{Float64}} (alias for Array{Array{Float64, 2}, 1})","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"xs[1]\n# output\n4×5 Matrix{Float64}:\n 0.50262     0.64885  0.771298   0.211364  0.206083\n 0.00261977  0.14885  0.271298   0.711364  0.706083\n 0.25262     0.89885  0.521298   0.461364  0.956083\n 0.75262     0.39885  0.0212976  0.961364  0.456083","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"xs[2]\n# output\n4×5 Matrix{Float64}:\n 0.583259   0.861213  0.781133  0.458726  0.93243\n 0.0832589  0.361213  0.281133  0.958726  0.43243\n 0.333259   0.611213  0.531133  0.208726  0.18243\n 0.833259   0.111213  0.031133  0.708726  0.68243","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"As with unrandomized sequences, we can get the next 4 points and then reset the generator with ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"xs = NextR(rds,4)\nxs[1]\n# output\n4×5 Matrix{Float64}:\n 0.87762  0.77385  0.396298  0.836364   0.331083\n 0.37762  0.27385  0.896298  0.336364   0.831083\n 0.12762  0.52385  0.146298  0.586364   0.581083\n 0.62762  0.02385  0.646298  0.0863639  0.0810831","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"xs[2]\n# output\n4×5 Matrix{Float64}:\n 0.958259  0.736213  0.406133  0.583726   0.55743\n 0.458259  0.236213  0.906133  0.0837258  0.0574296\n 0.208259  0.986213  0.156133  0.833726   0.30743\n 0.708259  0.486213  0.656133  0.333726   0.80743","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Reset!(rds)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Similarly for Lattices ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"rls = RandomShift(ls,2,11)\nxr = NextR(rls,4)\nxr[1]\n# output\n4×5 Matrix{Float64}:\n 0.408169  0.860346  0.338226   0.58282    0.961567\n 0.908169  0.360346  0.838226   0.0828199  0.461567\n 0.658169  0.610346  0.0882258  0.83282    0.211567\n 0.158169  0.110346  0.588226   0.33282    0.711567","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"xr[2]\n# output\n4×5 Matrix{Float64}:\n 0.515953   0.634856  0.376913  0.695549  0.187747\n 0.0159529  0.134856  0.876913  0.195549  0.687747\n 0.765953   0.384856  0.126913  0.945549  0.437747\n 0.265953   0.884856  0.626913  0.445549  0.937747","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Reset!(rls)","category":"page"},{"location":"tutorial/#Advanced-Features","page":"Tutorial","title":"Advanced Features","text":"","category":"section"},{"location":"tutorial/#Alternative-Generating-Matrices-and-Vectors","page":"Tutorial","title":"Alternative Generating Matrices and Vectors","text":"","category":"section"},{"location":"tutorial/#Pregenerated","page":"Tutorial","title":"Pregenerated","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We include many alternative generating matrices for digital sequences in this directory. To use an alternative, simply supply the relative path ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"ds = DigitalSeqB2G(3,\"sobolmats/sobol_alpha2_Bs64.col\")\nNext(ds,4)\n# output\n4×3 Matrix{Float64}:\n 0.0     0.0     0.0\n 0.75    0.75    0.75\n 0.6875  0.1875  0.9375\n 0.4375  0.9375  0.1875","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Alternative Lattice generating vectors are available in this directory. For Lattices, after supplying the path you also need to pass the m value in the file name","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"ls = LatticeSeqB2(3,\"exod8_base2_m13.txt\",13)\nNext(ls,4)\n# output\n4×3 Matrix{Float64}:\n 0.0   0.0   0.0\n 0.5   0.5   0.5\n 0.25  0.25  0.75\n 0.75  0.75  0.25","category":"page"},{"location":"tutorial/#User-Defined","page":"Tutorial","title":"User Defined","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"One may supply their own generating matrix to construct a base 2 digital sequence, for example","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"m = 5\nC1 = [BigInt(2^i) for i=0:(m-1)]\nC2 = [BigInt(1) for i=1:m]\nfor i in 2:m C2[i] = (C2[i-1] << 1) ⊻ C2[i-1] end\ngenerating_matrix = vcat(C1',C2')\n# output\n2×5 Matrix{BigInt}:\n 1  2  4   8  16\n 1  3  5  15  17","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"ds = DigitalSeqB2G(2,generating_matrix)\nNext(ds,4)\n# output\n4×2 Matrix{Float64}:\n 0.0   0.0\n 0.5   0.5\n 0.75  0.25\n 0.25  0.75","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For base 2 Lattices, you may supply the generating vector followed by m where 2^m is the maximum number of supported points ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"generating_vector = BigInt[1,433461,315689]\nm = 20\nls = LatticeSeqB2(3,generating_vector,m)\nNext(ls,4)\n# output\n4×3 Matrix{Float64}:\n 0.0   0.0   0.0\n 0.5   0.5   0.5\n 0.25  0.25  0.25\n 0.75  0.75  0.75","category":"page"},{"location":"tutorial/#Linear-Ordering","page":"Tutorial","title":"Linear Ordering","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"By default, digital sequences are generated in Gray code order. One may generate the first 2^m points in linear order via ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"m = 3\nn = 2^m\nds = DigitalSeqB2G(4)\nFirstLinear(ds,m)\n# output\n8×4 Matrix{Float64}:\n 0.0    0.0    0.0    0.0\n 0.5    0.5    0.5    0.5\n 0.25   0.75   0.75   0.75\n 0.75   0.25   0.25   0.25\n 0.125  0.625  0.375  0.125\n 0.625  0.125  0.875  0.625\n 0.375  0.375  0.625  0.875\n 0.875  0.875  0.125  0.375","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Compare to the original ordering ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Next(ds,n)\n# output\n8×4 Matrix{Float64}:\n 0.0    0.0    0.0    0.0\n 0.5    0.5    0.5    0.5\n 0.75   0.25   0.25   0.25\n 0.25   0.75   0.75   0.75\n 0.375  0.375  0.625  0.875\n 0.875  0.875  0.125  0.375\n 0.625  0.125  0.875  0.625\n 0.125  0.625  0.375  0.125","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Similarly, Lattices are by default generated in extensible ordering. A linear ordering is also available ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"m = 3\nn = 2^m \nls = LatticeSeqB2(4)\nFirstLinear(ls,m)\n# output\n8×4 Matrix{Float64}:\n 0.0    0.0    0.0    0.0\n 0.125  0.375  0.375  0.125\n 0.25   0.75   0.75   0.25\n 0.375  0.125  0.125  0.375\n 0.5    0.5    0.5    0.5\n 0.625  0.875  0.875  0.625\n 0.75   0.25   0.25   0.75\n 0.875  0.625  0.625  0.875","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Compare to the original ordering ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Next(ls,n)\n# output\n8×4 Matrix{Float64}:\n 0.0    0.0    0.0    0.0\n 0.5    0.5    0.5    0.5\n 0.25   0.75   0.75   0.25\n 0.75   0.25   0.25   0.75\n 0.125  0.375  0.375  0.125\n 0.625  0.875  0.875  0.625\n 0.375  0.125  0.125  0.375\n 0.875  0.625  0.625  0.875","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Linear order for randomized sequences has expected syntax ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"ds = DigitalSeqB2G(4)\nrds = RandomDigitalShift(ds,1,17)\nFirstLinear(rds,2)\n# output\n4×4 Matrix{Float64}:\n 0.971405  0.428212  0.121174  0.444364\n 0.471405  0.928212  0.621174  0.944364\n 0.721405  0.678212  0.871174  0.694364\n 0.221405  0.178212  0.371174  0.194364","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"rds = RandomDigitalShift(ds,2,17)\nxs = FirstRLinear(rds,2)\nxs[1]\n# output\n4×4 Matrix{Float64}:\n 0.971405  0.121174  0.0747568  0.82345\n 0.471405  0.621174  0.574757   0.32345\n 0.721405  0.871174  0.824757   0.07345\n 0.221405  0.371174  0.324757   0.57345","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"xs[2]\n# output\n4×4 Matrix{Float64}:\n 0.428212  0.444364  0.320031   0.705377\n 0.928212  0.944364  0.820031   0.205377\n 0.178212  0.694364  0.570031   0.455377\n 0.678212  0.194364  0.0700311  0.955377","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The same functions are available for randomly shifted lattices. ","category":"page"},{"location":"tutorial/#Binary-Functions-for-Digital-Sequences","page":"Tutorial","title":"Binary Functions for Digital Sequences","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For digital sequences, we sometimes want the binary representation of points. We can get the binary representations as integers and then convert them to their floating point values as follows ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"ds = DigitalSeqB2G(4)\nxb = NextBinary(ds,4)\n# output\n4×4 Matrix{BigInt}:\n          0           0           0           0\n 2147483648  2147483648  2147483648  2147483648\n 3221225472  1073741824  1073741824  1073741824\n 1073741824  3221225472  3221225472  3221225472","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"BinaryToFloat64(xb,ds)\n# output\n4×4 Matrix{Float64}:\n 0.0   0.0   0.0   0.0\n 0.5   0.5   0.5   0.5\n 0.75  0.25  0.25  0.25\n 0.25  0.75  0.75  0.75","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This is also compatible with randomized digital sequences ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Reset!(ds)\nrds_single = RandomDigitalShift(ds,1,11)\nxb = NextBinary(rds_single,4)\n# output\n4×4 Matrix{BigInt}:\n 2158735485  2505077772  2786789608  3698881025\n   11251837   357594124   639305960  1551397377\n 1084993661  3578819596  3860531432  2625139201\n 3232477309  1431335948  1713047784   477655553","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"BinaryToFloat64(xb,rds_single)\n# output\n4×4 Matrix{Float64}:\n 0.50262     0.583259   0.64885  0.861213\n 0.00261977  0.0832589  0.14885  0.361213\n 0.25262     0.833259   0.89885  0.611213\n 0.75262     0.333259   0.39885  0.111213","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Reset!(ds)\nrds_multiple = RandomDigitalShift(ds,2,11)\nxbs = NextRBinary(rds_multiple,4)\nxbs[1]\n# output\n4×4 Matrix{BigInt}:\n 2158735485  2786789608  3312698034   907801103\n   11251837   639305960  1165214386  3055284751\n 1084993661  3860531432  2238956210  1981542927\n 3232477309  1713047784    91472562  4129026575","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"xbs[2]\n# output\n4×4 Matrix{BigInt}:\n 2505077772  3698881025  3354940850  1970212149\n  357594124  1551397377  1207457202  4117695797\n 1431335948  2625139201  2281199026   896470325\n 3578819596   477655553   133715378  3043953973","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"BinaryToFloat64(xbs,rds_multiple)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Getting binary points with linear ordering is also supported. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Reset!(ds) # resets rds_single and rds_multiple as well\nFirstLinearBinary(ds,2)\n# output\n4×4 Matrix{BigInt}:\n          0           0           0           0\n 2147483648  2147483648  2147483648  2147483648\n 1073741824  3221225472  3221225472  3221225472\n 3221225472  1073741824  1073741824  1073741824","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"FirstLinearBinary(rds_single,2)\n# output\n4×4 Matrix{BigInt}:\n 2158735485  2505077772  2786789608  3698881025\n   11251837   357594124   639305960  1551397377\n 3232477309  1431335948  1713047784   477655553\n 1084993661  3578819596  3860531432  2625139201","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"xbs = FirstRLinearBinary(rds_multiple,2)\nxbs[1]\n# output\n4×4 Matrix{BigInt}:\n 2158735485  2786789608  3312698034   907801103\n   11251837   639305960  1165214386  3055284751\n 3232477309  1713047784    91472562  4129026575\n 1084993661  3860531432  2238956210  1981542927","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"xbs[2]\n# output\n4×4 Matrix{BigInt}:\n 2505077772  3698881025  3354940850  1970212149\n  357594124  1551397377  1207457202  4117695797\n 3578819596   477655553   133715378  3043953973\n 1431335948  2625139201  2281199026   896470325","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"These may be converted to floats as before. ","category":"page"}]
}
