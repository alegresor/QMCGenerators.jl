<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · QMCGenerators.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="QMCGenerators.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">QMCGenerators.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Tutorial</a><ul class="internal"><li><a class="tocitem" href="#Common-Usage"><span>Common Usage</span></a></li><li><a class="tocitem" href="#Structure-and-Functions"><span>Structure and Functions</span></a></li><li><a class="tocitem" href="#Advanced-Features"><span>Advanced Features</span></a></li><li><a class="tocitem" href="#Plotting"><span>Plotting</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/alegresor/QMCGenerators.jl/blob/main/docs/src/tutorial.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial"><a class="docs-heading-anchor" href="#Tutorial">Tutorial</a><a id="Tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial" title="Permalink"></a></h1><ul><li><a href="#Tutorial">Tutorial</a></li><li class="no-marker"><ul><li><a href="#Common-Usage">Common Usage</a></li><li><a href="#Structure-and-Functions">Structure and Functions</a></li><li class="no-marker"><ul><li><a href="#Unrandomized-Sequences">Unrandomized Sequences</a></li><li><a href="#Independent-Sequence-Randomizations">Independent Sequence Randomizations</a></li></ul></li><li><a href="#Advanced-Features">Advanced Features</a></li><li class="no-marker"><ul><li><a href="#Alternative-Generating-Matrices-and-Vectors">Alternative Generating Matrices and Vectors</a></li><li class="no-marker"><ul><li><a href="#Pregenerated">Pregenerated</a></li><li><a href="#User-Defined">User Defined</a></li></ul></li><li><a href="#Linear-Ordering">Linear Ordering</a></li><li><a href="#Binary-Functions-for-Digital-Sequences">Binary Functions for Digital Sequences</a></li><li><a href="#IID-Standard-Uniform-Generator">IID Standard Uniform Generator</a></li></ul></li><li><a href="#Plotting">Plotting</a></li><li class="no-marker"><ul><li><a href="#Single-Projection">Single Projection</a></li><li><a href="#Extensibility">Extensibility</a></li><li><a href="#Multiple-Projections">Multiple Projections</a></li><li><a href="#Multiple-Randomizations">Multiple Randomizations</a></li><li><a href="#Comparison-of-Sequences">Comparison of Sequences</a></li><li><a href="#MC-vs-QMC">MC vs QMC</a></li><li><a href="#Logo">Logo</a></li></ul></li></ul></li></ul><p>To begin, install this package with </p><pre><code class="language-julia hljs">Pkg.add(&quot;QMCGenerators&quot;)</code></pre><p>and then import via</p><pre><code class="language-julia hljs">using QMCGenerators</code></pre><h2 id="Common-Usage"><a class="docs-heading-anchor" href="#Common-Usage">Common Usage</a><a id="Common-Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Common-Usage" title="Permalink"></a></h2><p>Often we just want to generate a single randomized quasi-random sequence. For example, to generate the first 4 points of a 3 dimensional digital net with 1 random digital shift with seed 7</p><pre><code class="language-julia hljs">Next(RandomDigitalShift(DigitalSeqB2G(3),1,7),4)
# output
4×3 Matrix{Float64}:
 0.648627  0.0158008  0.971646
 0.148627  0.515801   0.471646
 0.398627  0.265801   0.721646
 0.898627  0.765801   0.221646</code></pre><p>A similar API is available for randomly shifted Lattices:</p><pre><code class="language-julia hljs">Next(RandomShift(LatticeSeqB2(3),1,7),4)
# output
4×3 Matrix{Float64}:
 0.812439   0.654977  0.489613
 0.312439   0.154977  0.989613
 0.0624386  0.404977  0.239613
 0.562439   0.904977  0.739613</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>While not strictly enforced, sample sizes should be powers of two to achieve full coverage of <span>$[0,1]^s$</span></p></div></div><p>In the following sections we always supply a seed for reproducibility. Supplying a seed requires you also supply the number of randomizations as done above. However, if you do not wish to seed, you can simply supply the number of randomizations. </p><pre><code class="language-julia hljs">rls = RandomDigitalShift(DigitalSeqB2G(12),2)
xs = NextR(rls,2^7)
size(xs)
# output
(2,)</code></pre><pre><code class="language-julia hljs">size(xs[1]) == size(xs[2]) == (2^7,12)
# output
true</code></pre><p>Moreover, you may use only one randomization without a seed with the simplified API</p><pre><code class="language-julia hljs">rls = RandomDigitalShift(DigitalSeqB2G(52))
x = Next(rls,2^14)
size(x)
# output
(16384, 52)</code></pre><p>The same API simplifications holds for Lattices. </p><h2 id="Structure-and-Functions"><a class="docs-heading-anchor" href="#Structure-and-Functions">Structure and Functions</a><a id="Structure-and-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Structure-and-Functions" title="Permalink"></a></h2><h3 id="Unrandomized-Sequences"><a class="docs-heading-anchor" href="#Unrandomized-Sequences">Unrandomized Sequences</a><a id="Unrandomized-Sequences-1"></a><a class="docs-heading-anchor-permalink" href="#Unrandomized-Sequences" title="Permalink"></a></h3><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>It is highly recommended you randomize sequences. The first point of an unrandomized sequence is <span>$0 \in [0,1]^s$</span> which will be transformed to an infinite values in many functions e.g. those composed with taking the inverse CDF of a <span>$\mathcal{N}(0,1)$</span> as done in the section on <a href="../#Quasi-Monte-Carlo">Quasi-Monte Carlo</a>. </p></div></div><p>Let&#39;s start by defining a 5 dimensional (unrandomized) digital sequence and generating the first 4 points.</p><pre><code class="language-julia hljs">ds = DigitalSeqB2G(5)
Next(ds,4)
# output
4×5 Matrix{Float64}:
 0.0   0.0   0.0   0.0   0.0
 0.5   0.5   0.5   0.5   0.5
 0.75  0.25  0.25  0.25  0.75
 0.25  0.75  0.75  0.75  0.25</code></pre><p>We can then generate the next 4 points in the sequence with </p><pre><code class="language-julia hljs">Next(ds,4)
# output
4×5 Matrix{Float64}:
 0.375  0.375  0.625  0.875  0.375
 0.875  0.875  0.125  0.375  0.875
 0.625  0.125  0.875  0.625  0.625
 0.125  0.625  0.375  0.125  0.125</code></pre><p>To reset the generator use</p><pre><code class="language-julia hljs">Reset!(ds)
Next(ds,4)
# output
4×5 Matrix{Float64}:
 0.0   0.0   0.0   0.0   0.0
 0.5   0.5   0.5   0.5   0.5
 0.75  0.25  0.25  0.25  0.75
 0.25  0.75  0.75  0.75  0.25</code></pre><p>Let&#39;s reset once more before continuing </p><pre><code class="language-julia hljs">Reset!(ds)
# output</code></pre><p>These functions can also be applied to Lattices </p><pre><code class="language-julia hljs">ls = LatticeSeqB2(5)
Next(ls,4)
# output
4×5 Matrix{Float64}:
 0.0   0.0   0.0   0.0   0.0
 0.5   0.5   0.5   0.5   0.5
 0.25  0.75  0.75  0.25  0.25
 0.75  0.25  0.25  0.75  0.75</code></pre><pre><code class="language-julia hljs">Next(ls,4)
# output
4×5 Matrix{Float64}:
 0.125  0.375  0.375  0.125  0.125
 0.625  0.875  0.875  0.625  0.625
 0.375  0.125  0.125  0.375  0.375
 0.875  0.625  0.625  0.875  0.875</code></pre><pre><code class="language-julia hljs">Reset!(ls)
# output</code></pre><h3 id="Independent-Sequence-Randomizations"><a class="docs-heading-anchor" href="#Independent-Sequence-Randomizations">Independent Sequence Randomizations</a><a id="Independent-Sequence-Randomizations-1"></a><a class="docs-heading-anchor-permalink" href="#Independent-Sequence-Randomizations" title="Permalink"></a></h3><p>Getting a single randomization was shown in the <a href="#Common-Usage">Common Usage</a> section. Support is also available for multiple independent randomizations. For instance, we can generating 2 independent randomizations with seed 11 and get the next 4 points in each sequence via  </p><pre><code class="language-julia hljs">rds = RandomDigitalShift(ds,2,11)
xs = NextR(rds,4)
typeof(xs)
# output
Vector{Matrix{Float64}} (alias for Array{Array{Float64, 2}, 1})</code></pre><pre><code class="language-julia hljs">xs[1]
# output
4×5 Matrix{Float64}:
 0.50262     0.64885  0.771298   0.211364  0.206083
 0.00261977  0.14885  0.271298   0.711364  0.706083
 0.25262     0.89885  0.521298   0.461364  0.956083
 0.75262     0.39885  0.0212976  0.961364  0.456083</code></pre><pre><code class="language-julia hljs">xs[2]
# output
4×5 Matrix{Float64}:
 0.583259   0.861213  0.781133  0.458726  0.93243
 0.0832589  0.361213  0.281133  0.958726  0.43243
 0.333259   0.611213  0.531133  0.208726  0.18243
 0.833259   0.111213  0.031133  0.708726  0.68243</code></pre><p>As with unrandomized sequences, we can get the next 4 points and then reset the generator with </p><pre><code class="language-julia hljs">xs = NextR(rds,4)
xs[1]
# output
4×5 Matrix{Float64}:
 0.87762  0.77385  0.396298  0.836364   0.331083
 0.37762  0.27385  0.896298  0.336364   0.831083
 0.12762  0.52385  0.146298  0.586364   0.581083
 0.62762  0.02385  0.646298  0.0863639  0.0810831</code></pre><pre><code class="language-julia hljs">xs[2]
# output
4×5 Matrix{Float64}:
 0.958259  0.736213  0.406133  0.583726   0.55743
 0.458259  0.236213  0.906133  0.0837258  0.0574296
 0.208259  0.986213  0.156133  0.833726   0.30743
 0.708259  0.486213  0.656133  0.333726   0.80743</code></pre><pre><code class="language-julia hljs">Reset!(rds)
# output</code></pre><p>Similarly for Lattices </p><pre><code class="language-julia hljs">rls = RandomShift(ls,2,11)
xr = NextR(rls,4)
xr[1]
# output
4×5 Matrix{Float64}:
 0.408169  0.860346  0.338226   0.58282    0.961567
 0.908169  0.360346  0.838226   0.0828199  0.461567
 0.658169  0.610346  0.0882258  0.83282    0.211567
 0.158169  0.110346  0.588226   0.33282    0.711567</code></pre><pre><code class="language-julia hljs">xr[2]
# output
4×5 Matrix{Float64}:
 0.515953   0.634856  0.376913  0.695549  0.187747
 0.0159529  0.134856  0.876913  0.195549  0.687747
 0.765953   0.384856  0.126913  0.945549  0.437747
 0.265953   0.884856  0.626913  0.445549  0.937747</code></pre><pre><code class="language-julia hljs">Reset!(rls)
# output</code></pre><h2 id="Advanced-Features"><a class="docs-heading-anchor" href="#Advanced-Features">Advanced Features</a><a id="Advanced-Features-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-Features" title="Permalink"></a></h2><h3 id="Alternative-Generating-Matrices-and-Vectors"><a class="docs-heading-anchor" href="#Alternative-Generating-Matrices-and-Vectors">Alternative Generating Matrices and Vectors</a><a id="Alternative-Generating-Matrices-and-Vectors-1"></a><a class="docs-heading-anchor-permalink" href="#Alternative-Generating-Matrices-and-Vectors" title="Permalink"></a></h3><h4 id="Pregenerated"><a class="docs-heading-anchor" href="#Pregenerated">Pregenerated</a><a id="Pregenerated-1"></a><a class="docs-heading-anchor-permalink" href="#Pregenerated" title="Permalink"></a></h4><p>We include many alternative generating matrices for digital sequences in <a href="https://bitbucket.org/dnuyens/qmc-generators/src/master/DIGSEQ/">this directory</a>. To use an alternative, simply supply the relative path </p><pre><code class="language-julia hljs">ds = DigitalSeqB2G(3,&quot;sobolmats/sobol_alpha2_Bs64.col&quot;)
Next(ds,4)
# output
4×3 Matrix{Float64}:
 0.0     0.0     0.0
 0.75    0.75    0.75
 0.6875  0.1875  0.9375
 0.4375  0.9375  0.1875</code></pre><p>Alternative Lattice generating vectors are available in <a href="https://bitbucket.org/dnuyens/qmc-generators/src/master/LATSEQ/">this directory</a>. For Lattices, after supplying the path you also need to pass the <span>$m$</span> value in the file name</p><pre><code class="language-julia hljs">ls = LatticeSeqB2(3,&quot;exod8_base2_m13.txt&quot;,13)
Next(ls,4)
# output
4×3 Matrix{Float64}:
 0.0   0.0   0.0
 0.5   0.5   0.5
 0.25  0.25  0.75
 0.75  0.75  0.25</code></pre><h4 id="User-Defined"><a class="docs-heading-anchor" href="#User-Defined">User Defined</a><a id="User-Defined-1"></a><a class="docs-heading-anchor-permalink" href="#User-Defined" title="Permalink"></a></h4><p>One may supply their own generating matrix to construct a base 2 digital sequence, for example</p><pre><code class="language-julia hljs">m = 5
C1 = [BigInt(2^i) for i=0:(m-1)]
C2 = [BigInt(1) for i=1:m]
for i in 2:m C2[i] = (C2[i-1] &lt;&lt; 1) ⊻ C2[i-1] end
generating_matrix = vcat(C1&#39;,C2&#39;)
# output
2×5 Matrix{BigInt}:
 1  2  4   8  16
 1  3  5  15  17</code></pre><pre><code class="language-julia hljs">ds = DigitalSeqB2G(2,generating_matrix)
Next(ds,4)
# output
4×2 Matrix{Float64}:
 0.0   0.0
 0.5   0.5
 0.75  0.25
 0.25  0.75</code></pre><p>For base 2 Lattices, you may supply the generating vector followed by <span>$m$</span> where <span>$2^m$</span> is the maximum number of supported points </p><pre><code class="language-julia hljs">generating_vector = BigInt[1,433461,315689]
m = 20
ls = LatticeSeqB2(3,generating_vector,m)
Next(ls,4)
# output
4×3 Matrix{Float64}:
 0.0   0.0   0.0
 0.5   0.5   0.5
 0.25  0.25  0.25
 0.75  0.75  0.75</code></pre><h3 id="Linear-Ordering"><a class="docs-heading-anchor" href="#Linear-Ordering">Linear Ordering</a><a id="Linear-Ordering-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-Ordering" title="Permalink"></a></h3><p>By default, digital sequences are generated in Gray code order. One may generate the first <span>$2^m$</span> points in linear order via </p><pre><code class="language-julia hljs">m = 3
n = 2^m
ds = DigitalSeqB2G(4)
FirstLinear(ds,m)
# output
8×4 Matrix{Float64}:
 0.0    0.0    0.0    0.0
 0.5    0.5    0.5    0.5
 0.25   0.75   0.75   0.75
 0.75   0.25   0.25   0.25
 0.125  0.625  0.375  0.125
 0.625  0.125  0.875  0.625
 0.375  0.375  0.625  0.875
 0.875  0.875  0.125  0.375</code></pre><p>Compare to the original ordering </p><pre><code class="language-julia hljs">Next(ds,n)
# output
8×4 Matrix{Float64}:
 0.0    0.0    0.0    0.0
 0.5    0.5    0.5    0.5
 0.75   0.25   0.25   0.25
 0.25   0.75   0.75   0.75
 0.375  0.375  0.625  0.875
 0.875  0.875  0.125  0.375
 0.625  0.125  0.875  0.625
 0.125  0.625  0.375  0.125</code></pre><p>Similarly, Lattices are by default generated in extensible ordering. A linear ordering is also available </p><pre><code class="language-julia hljs">m = 3
n = 2^m 
ls = LatticeSeqB2(4)
FirstLinear(ls,m)
# output
8×4 Matrix{Float64}:
 0.0    0.0    0.0    0.0
 0.125  0.375  0.375  0.125
 0.25   0.75   0.75   0.25
 0.375  0.125  0.125  0.375
 0.5    0.5    0.5    0.5
 0.625  0.875  0.875  0.625
 0.75   0.25   0.25   0.75
 0.875  0.625  0.625  0.875</code></pre><p>Compare to the original ordering </p><pre><code class="language-julia hljs">Next(ls,n)
# output
8×4 Matrix{Float64}:
 0.0    0.0    0.0    0.0
 0.5    0.5    0.5    0.5
 0.25   0.75   0.75   0.25
 0.75   0.25   0.25   0.75
 0.125  0.375  0.375  0.125
 0.625  0.875  0.875  0.625
 0.375  0.125  0.125  0.375
 0.875  0.625  0.625  0.875</code></pre><p>Linear order for randomized sequences has expected syntax </p><pre><code class="language-julia hljs">ds = DigitalSeqB2G(4)
rds = RandomDigitalShift(ds,1,17)
FirstLinear(rds,2)
# output
4×4 Matrix{Float64}:
 0.971405  0.428212  0.121174  0.444364
 0.471405  0.928212  0.621174  0.944364
 0.721405  0.678212  0.871174  0.694364
 0.221405  0.178212  0.371174  0.194364</code></pre><pre><code class="language-julia hljs">rds = RandomDigitalShift(ds,2,17)
xs = FirstRLinear(rds,2)
xs[1]
# output
4×4 Matrix{Float64}:
 0.971405  0.121174  0.0747568  0.82345
 0.471405  0.621174  0.574757   0.32345
 0.721405  0.871174  0.824757   0.07345
 0.221405  0.371174  0.324757   0.57345</code></pre><pre><code class="language-julia hljs">xs[2]
# output
4×4 Matrix{Float64}:
 0.428212  0.444364  0.320031   0.705377
 0.928212  0.944364  0.820031   0.205377
 0.178212  0.694364  0.570031   0.455377
 0.678212  0.194364  0.0700311  0.955377</code></pre><p>The same functions are available for randomly shifted lattices. </p><h3 id="Binary-Functions-for-Digital-Sequences"><a class="docs-heading-anchor" href="#Binary-Functions-for-Digital-Sequences">Binary Functions for Digital Sequences</a><a id="Binary-Functions-for-Digital-Sequences-1"></a><a class="docs-heading-anchor-permalink" href="#Binary-Functions-for-Digital-Sequences" title="Permalink"></a></h3><p>For digital sequences, we sometimes want the binary representation of points. We can get the binary representations as integers and then convert them to their floating point values as follows </p><pre><code class="language-julia hljs">ds = DigitalSeqB2G(4)
xb = NextBinary(ds,4)
# output
4×4 Matrix{BigInt}:
          0           0           0           0
 2147483648  2147483648  2147483648  2147483648
 3221225472  1073741824  1073741824  1073741824
 1073741824  3221225472  3221225472  3221225472</code></pre><pre><code class="language-julia hljs">BinaryToFloat64(xb,ds)
# output
4×4 Matrix{Float64}:
 0.0   0.0   0.0   0.0
 0.5   0.5   0.5   0.5
 0.75  0.25  0.25  0.25
 0.25  0.75  0.75  0.75</code></pre><p>This is also compatible with randomized digital sequences </p><pre><code class="language-julia hljs">Reset!(ds)
rds_single = RandomDigitalShift(ds,1,11)
xb = NextBinary(rds_single,4)
# output
4×4 Matrix{BigInt}:
 2158735485  2505077772  2786789608  3698881025
   11251837   357594124   639305960  1551397377
 1084993661  3578819596  3860531432  2625139201
 3232477309  1431335948  1713047784   477655553</code></pre><pre><code class="language-julia hljs">BinaryToFloat64(xb,rds_single)
# output
4×4 Matrix{Float64}:
 0.50262     0.583259   0.64885  0.861213
 0.00261977  0.0832589  0.14885  0.361213
 0.25262     0.833259   0.89885  0.611213
 0.75262     0.333259   0.39885  0.111213</code></pre><pre><code class="language-julia hljs">Reset!(ds)
rds_multiple = RandomDigitalShift(ds,2,11)
xbs = NextRBinary(rds_multiple,4)
xbs[1]
# output
4×4 Matrix{BigInt}:
 2158735485  2786789608  3312698034   907801103
   11251837   639305960  1165214386  3055284751
 1084993661  3860531432  2238956210  1981542927
 3232477309  1713047784    91472562  4129026575</code></pre><pre><code class="language-julia hljs">xbs[2]
# output
4×4 Matrix{BigInt}:
 2505077772  3698881025  3354940850  1970212149
  357594124  1551397377  1207457202  4117695797
 1431335948  2625139201  2281199026   896470325
 3578819596   477655553   133715378  3043953973</code></pre><pre><code class="language-julia hljs">BinaryToFloat64(xbs,rds_multiple)</code></pre><p>Getting binary points with linear ordering is also supported. </p><pre><code class="language-julia hljs">Reset!(ds) # resets rds_single and rds_multiple as well
FirstLinearBinary(ds,2)
# output
4×4 Matrix{BigInt}:
          0           0           0           0
 2147483648  2147483648  2147483648  2147483648
 1073741824  3221225472  3221225472  3221225472
 3221225472  1073741824  1073741824  1073741824</code></pre><pre><code class="language-julia hljs">FirstLinearBinary(rds_single,2)
# output
4×4 Matrix{BigInt}:
 2158735485  2505077772  2786789608  3698881025
   11251837   357594124   639305960  1551397377
 3232477309  1431335948  1713047784   477655553
 1084993661  3578819596  3860531432  2625139201</code></pre><pre><code class="language-julia hljs">xbs = FirstRLinearBinary(rds_multiple,2)
xbs[1]
# output
4×4 Matrix{BigInt}:
 2158735485  2786789608  3312698034   907801103
   11251837   639305960  1165214386  3055284751
 3232477309  1713047784    91472562  4129026575
 1084993661  3860531432  2238956210  1981542927</code></pre><pre><code class="language-julia hljs">xbs[2]
# output
4×4 Matrix{BigInt}:
 2505077772  3698881025  3354940850  1970212149
  357594124  1551397377  1207457202  4117695797
 3578819596   477655553   133715378  3043953973
 1431335948  2625139201  2281199026   896470325</code></pre><p>These may be converted to floats as before. </p><h3 id="IID-Standard-Uniform-Generator"><a class="docs-heading-anchor" href="#IID-Standard-Uniform-Generator">IID Standard Uniform Generator</a><a id="IID-Standard-Uniform-Generator-1"></a><a class="docs-heading-anchor-permalink" href="#IID-Standard-Uniform-Generator" title="Permalink"></a></h3><p>We provide an IID <span>$\mathcal{U}[0,1]^s$</span> generator with the same API as Lattice and digital sequences. This is a wrapper around <a href="https://docs.julialang.org/en/v1/stdlib/Random/#Random.MersenneTwister"><code>Random.MersenneTwister</code></a>.</p><p>For reproducibility, you may provide a seed.</p><pre><code class="language-julia hljs">iiduseq = IIDU01Seq(3,7)
Next(iiduseq,4)
# output
4×3 Matrix{Float64}:
 0.812439   0.654977  0.489613
 0.0787595  0.581591  0.258053
 0.196465   0.193925  0.842951
 0.66193    0.401352  0.635904</code></pre><pre><code class="language-julia hljs">Reset!(iiduseq)
Next(iiduseq,4)
# output
4×3 Matrix{Float64}:
 0.812439   0.654977  0.489613
 0.0787595  0.581591  0.258053
 0.196465   0.193925  0.842951
 0.66193    0.401352  0.635904</code></pre><p>The seed gets used to construct a <code>MersenneTwister</code>. After</p><pre><code class="language-julia hljs">using Random: MersenneTwister</code></pre><p>You may pass also pass a <code>MersenneTwister</code> instance directly.</p><pre><code class="language-julia hljs">iiduseq = IIDU01Seq(3,MersenneTwister(7))
Next(iiduseq,4)
# output
4×3 Matrix{Float64}:
 0.812439   0.654977  0.489613
 0.0787595  0.581591  0.258053
 0.196465   0.193925  0.842951
 0.66193    0.401352  0.635904</code></pre><p>Providing neither a seed nor <code>MersenneTwister</code> uses <code>MersenneTwister()</code>.</p><pre><code class="language-julia hljs">iiduseq = IIDU01Seq(3)
size(Next(iiduseq,4))
# output
(4, 3)</code></pre><h2 id="Plotting"><a class="docs-heading-anchor" href="#Plotting">Plotting</a><a id="Plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting" title="Permalink"></a></h2><p>To save figures we need to ensure we are</p><pre><code class="language-julia hljs">using CairoMakie</code></pre><h3 id="Single-Projection"><a class="docs-heading-anchor" href="#Single-Projection">Single Projection</a><a id="Single-Projection-1"></a><a class="docs-heading-anchor-permalink" href="#Single-Projection" title="Permalink"></a></h3><pre><code class="language-julia hljs">PLOTDIR = joinpath(@__DIR__,&quot;src/assets&quot;)
n = 2^6
ds = DigitalSeqB2G(3)
fig = qmcscatter!(ds,n)
save(joinpath(PLOTDIR,&quot;basic.svg&quot;),fig)</code></pre><p><img src="../assets/basic.svg" alt="image"/></p><h3 id="Extensibility"><a class="docs-heading-anchor" href="#Extensibility">Extensibility</a><a id="Extensibility-1"></a><a class="docs-heading-anchor-permalink" href="#Extensibility" title="Permalink"></a></h3><pre><code class="language-julia hljs">nvec = [1,2^6,2^7,2^8]
fig = qmcscatter!(ds,nvec)
save(joinpath(PLOTDIR,&quot;extensibility.svg&quot;),fig)</code></pre><p><img src="../assets/extensibility.svg" alt="image"/></p><h3 id="Multiple-Projections"><a class="docs-heading-anchor" href="#Multiple-Projections">Multiple Projections</a><a id="Multiple-Projections-1"></a><a class="docs-heading-anchor-permalink" href="#Multiple-Projections" title="Permalink"></a></h3><pre><code class="language-julia hljs">dvec = [1 2; 1 3; 2 3]
fig = qmcscatter!(ds,nvec,dvec)
save(joinpath(PLOTDIR,&quot;projections.svg&quot;),fig)</code></pre><p><img src="../assets/projections.svg" alt="image"/></p><h3 id="Multiple-Randomizations"><a class="docs-heading-anchor" href="#Multiple-Randomizations">Multiple Randomizations</a><a id="Multiple-Randomizations-1"></a><a class="docs-heading-anchor-permalink" href="#Multiple-Randomizations" title="Permalink"></a></h3><pre><code class="language-julia hljs">rds = RandomDigitalShift(DigitalSeqB2G(3),3)
fig = qmcscatter!(rds,nvec,dvec)
save(joinpath(PLOTDIR,&quot;randomizations.svg&quot;),fig)</code></pre><p><img src="../assets/randomizations.svg" alt="image"/></p><h3 id="Comparison-of-Sequences"><a class="docs-heading-anchor" href="#Comparison-of-Sequences">Comparison of Sequences</a><a id="Comparison-of-Sequences-1"></a><a class="docs-heading-anchor-permalink" href="#Comparison-of-Sequences" title="Permalink"></a></h3><pre><code class="language-julia hljs">iid = IIDU01Seq(3)
rds = RandomDigitalShift(DigitalSeqB2G(3))
rls = RandomShift(LatticeSeqB2(3))
fig = qmcscatter!([1,2^6,2^7,2^8],[1 2],iid=iid,rds=rds,rls=rls)
save(joinpath(PLOTDIR,&quot;seq_comparison.svg&quot;),fig)</code></pre><p><img src="../assets/seq_comparison.svg" alt="image"/></p><h3 id="MC-vs-QMC"><a class="docs-heading-anchor" href="#MC-vs-QMC">MC vs QMC</a><a id="MC-vs-QMC-1"></a><a class="docs-heading-anchor-permalink" href="#MC-vs-QMC" title="Permalink"></a></h3><p>We also need to be </p><pre><code class="language-julia hljs">using Distributions
using LinearAlgebra</code></pre><pre><code class="language-julia hljs">m = 16
r = 100
seed = 7
n = 2^m
s,mu = 7,-11.05684907978818
rseqs = [IIDU01Seq(s,seed),RandomShift(LatticeSeqB2(s),r,seed),RandomDigitalShift(DigitalSeqB2G(s),r,seed)]
xsets = [
    [Next(rseqs[1],n) for k=1:r],
    NextR(rseqs[2],n),
    NextR(rseqs[3],n)]
f(x::Vector{Float64}) = π^(s/2)*cos(norm(quantile.(Normal(),x)/sqrt(2)));
f(x::Matrix{Float64}) = map(i-&gt;f(x[i,:]),1:size(x,1))
fig = Figure(resolution=(800,500))
ax = Axis(fig[2,1],
    xlabel = L&quot;$n$&quot;,
    ylabel = L&quot;$| \hat{\mu} - \mu |$&quot;,
    yscale = log10,
    xscale = log2)
xlims!(ax,[1,n])
for k=1:size(xsets,1)
    name,xs = rseqs[k].name,xsets[k]
    ys = vcat(map(i-&gt;f(xs[i]),1:r)&#39;...)
    muhats = cumsum(ys,dims=2); for i=1:r muhats[i,:] = muhats[i,:]./[i for i=1:n] end 
    err = abs.(muhats.-mu)
    pows2 = 2 .^ (0:m)
    qlowerr = map(p2-&gt;quantile(err[:,p2],.35),pows2)
    qmid = map(p2-&gt;quantile(err[:,p2],.5),pows2)
    qhigherr = map(p2-&gt;quantile(err[:,p2],.65),pows2)
    lines!(ax,pows2,qmid,color=JULIA4LOGOCOLORS[k],label=name,linewidth=3)
    band!(pows2,qhigherr,qlowerr,color=(JULIA4LOGOCOLORS[k],.3))
end
fig[1,1] = Legend(fig,ax,framevisible=false,orientation=:horizontal)
hidespines!(ax, :t, :r)
save(joinpath(PLOTDIR,&quot;mc_vs_qmc.svg&quot;),fig)</code></pre><p><img src="../assets/mc_vs_qmc.svg" alt="image"/></p><h3 id="Logo"><a class="docs-heading-anchor" href="#Logo">Logo</a><a id="Logo-1"></a><a class="docs-heading-anchor-permalink" href="#Logo" title="Permalink"></a></h3><pre><code class="language-julia hljs">nvec = [1,4,16,64]
rds = RandomDigitalShift(DigitalSeqB2G(2),1,17)
x = Next(rds,maximum(nvec))
fig = Figure(resolution=(500,500),backgroundcolor=:transparent)
ax = Axis(fig[1,1],aspect=1,xticklabelsvisible=false,yticklabelsvisible=false,backgroundcolor=:transparent)
qmcscatter!(ax,x,nvec)
limits!(ax,[-0.01,1.01],[-0.01,1.01])
for i=1:7 vlines!(ax,i/8,color=JULIA4LOGOCOLORS[3],alpha=1); hlines!(ax,i/8,color=JULIA4LOGOCOLORS[3],alpha=1) end 
for i=1:3 vlines!(ax,i/4,color=JULIA4LOGOCOLORS[2],alpha=1); hlines!(ax,i/4,color=JULIA4LOGOCOLORS[2],alpha=1) end 
for i=1:1 vlines!(ax,i/2,color=JULIA4LOGOCOLORS[1],alpha=1); hlines!(ax,i/2,color=JULIA4LOGOCOLORS[1],alpha=1) end 
hidespines!(ax); hidedecorations!(ax); hidexdecorations!(ax,grid = false); hideydecorations!(ax, ticks = false)
save(joinpath(PLOTDIR,&quot;logo.svg&quot;),fig)</code></pre><p><img src="../assets/logo.svg" alt="image"/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Monday 3 July 2023 17:08">Monday 3 July 2023</span>. Using Julia version 1.9.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
