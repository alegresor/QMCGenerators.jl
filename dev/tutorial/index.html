<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · QMCGenerators.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="QMCGenerators.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">QMCGenerators.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Tutorial</a><ul class="internal"><li><a class="tocitem" href="#Common-Usage"><span>Common Usage</span></a></li><li><a class="tocitem" href="#Structure-and-Functions"><span>Structure and Functions</span></a></li><li><a class="tocitem" href="#Advanced-Features"><span>Advanced Features</span></a></li><li><a class="tocitem" href="#Plotting"><span>Plotting</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/alegresor/QMCGenerators.jl/blob/main/docs/src/tutorial.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial"><a class="docs-heading-anchor" href="#Tutorial">Tutorial</a><a id="Tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial" title="Permalink"></a></h1><ul><li><a href="#Tutorial">Tutorial</a></li><li class="no-marker"><ul><li><a href="#Common-Usage">Common Usage</a></li><li><a href="#Structure-and-Functions">Structure and Functions</a></li><li class="no-marker"><ul><li><a href="#Unrandomized-Sequences">Unrandomized Sequences</a></li><li><a href="#Independent-Sequence-Randomizations">Independent Sequence Randomizations</a></li></ul></li><li><a href="#Advanced-Features">Advanced Features</a></li><li class="no-marker"><ul><li><a href="#Alternative-Generating-Matrices-and-Vectors">Alternative Generating Matrices and Vectors</a></li><li class="no-marker"><ul><li><a href="#Pregenerated">Pregenerated</a></li><li><a href="#User-Defined">User Defined</a></li></ul></li><li><a href="#Linear-Ordering">Linear Ordering</a></li><li><a href="#Binary-Functions-for-Digital-Sequences">Binary Functions for Digital Sequences</a></li><li><a href="#IID-Standard-Uniform-Generator">IID Standard Uniform Generator</a></li></ul></li><li><a href="#Plotting">Plotting</a></li><li class="no-marker"><ul><li><a href="#Single-Projection">Single Projection</a></li><li><a href="#Extensibility">Extensibility</a></li><li><a href="#Multiple-Projections">Multiple Projections</a></li><li><a href="#Multiple-Randomizations">Multiple Randomizations</a></li><li><a href="#Comparison-of-Sequences">Comparison of Sequences</a></li><li><a href="#MC-vs-QMC">MC vs QMC</a></li><li><a href="#Logo">Logo</a></li></ul></li></ul></li></ul><p>To begin, install this package with </p><pre><code class="language-julia hljs">Pkg.add(&quot;QMCGenerators&quot;)</code></pre><p>and then import via</p><pre><code class="language-julia hljs">using QMCGenerators</code></pre><h2 id="Common-Usage"><a class="docs-heading-anchor" href="#Common-Usage">Common Usage</a><a id="Common-Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Common-Usage" title="Permalink"></a></h2><p>Often we just want to generate a single randomized quasi-random sequence. For example, to generate the first 4 points of a 3 dimensional digital net with 1 random digital shift with seed 7</p><pre><code class="language-julia hljs">Next(RandomDigitalShift(DigitalSeqB2G(3),1,7),4)
# output
4×3 Matrix{Float64}:
 0.243795  0.719182  0.810814
 0.743795  0.219182  0.310814
 0.993795  0.969182  0.560814
 0.493795  0.469182  0.0608139</code></pre><p>A similar API is available for randomly shifted Lattices:</p><pre><code class="language-julia hljs">Next(RandomShift(LatticeSeqB2(3),1,7),4)
# output
4×3 Matrix{Float64}:
 0.243795  0.719182  0.810814
 0.743795  0.219182  0.310814
 0.493795  0.969182  0.0608139
 0.993795  0.469182  0.560814</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>While not strictly enforced, sample sizes should be powers of two to achieve full coverage of <span>$[0,1]^s$</span></p></div></div><p>In the following sections we always supply a seed for reproducibility. Supplying a seed requires you also supply the number of randomizations as done above. However, if you do not wish to seed, you can simply supply the number of randomizations. </p><pre><code class="language-julia hljs">rls = RandomDigitalShift(DigitalSeqB2G(12),2)
xs = NextR(rls,2^7)
size(xs)
# output
(2,)</code></pre><pre><code class="language-julia hljs">size(xs[1]) == size(xs[2]) == (2^7,12)
# output
true</code></pre><p>Moreover, you may use only one randomization without a seed with the simplified API</p><pre><code class="language-julia hljs">rls = RandomDigitalShift(DigitalSeqB2G(52))
x = Next(rls,2^14)
size(x)
# output
(16384, 52)</code></pre><p>The same API simplifications holds for Lattices. </p><h2 id="Structure-and-Functions"><a class="docs-heading-anchor" href="#Structure-and-Functions">Structure and Functions</a><a id="Structure-and-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Structure-and-Functions" title="Permalink"></a></h2><h3 id="Unrandomized-Sequences"><a class="docs-heading-anchor" href="#Unrandomized-Sequences">Unrandomized Sequences</a><a id="Unrandomized-Sequences-1"></a><a class="docs-heading-anchor-permalink" href="#Unrandomized-Sequences" title="Permalink"></a></h3><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>It is highly recommended you randomize sequences. The first point of an unrandomized sequence is <span>$0 \in [0,1]^s$</span> which will be transformed to an infinite values in many functions e.g. those composed with taking the inverse CDF of a <span>$\mathcal{N}(0,1)$</span> as done in the section on <a href="../#Quasi-Monte-Carlo">Quasi-Monte Carlo</a>. </p></div></div><p>Let&#39;s start by defining a 5 dimensional (unrandomized) digital sequence and generating the first 4 points.</p><pre><code class="language-julia hljs">ds = DigitalSeqB2G(5)
Next(ds,4)
# output
4×5 Matrix{Float64}:
 0.0   0.0   0.0   0.0   0.0
 0.5   0.5   0.5   0.5   0.5
 0.75  0.25  0.25  0.25  0.75
 0.25  0.75  0.75  0.75  0.25</code></pre><p>We can then generate the next 4 points in the sequence with </p><pre><code class="language-julia hljs">Next(ds,4)
# output
4×5 Matrix{Float64}:
 0.375  0.375  0.625  0.875  0.375
 0.875  0.875  0.125  0.375  0.875
 0.625  0.125  0.875  0.625  0.625
 0.125  0.625  0.375  0.125  0.125</code></pre><p>To reset the generator use</p><pre><code class="language-julia hljs">Reset!(ds)
Next(ds,4)
# output
4×5 Matrix{Float64}:
 0.0   0.0   0.0   0.0   0.0
 0.5   0.5   0.5   0.5   0.5
 0.75  0.25  0.25  0.25  0.75
 0.25  0.75  0.75  0.75  0.25</code></pre><p>Let&#39;s reset once more before continuing </p><pre><code class="language-julia hljs">Reset!(ds)
# output</code></pre><p>These functions can also be applied to Lattices </p><pre><code class="language-julia hljs">ls = LatticeSeqB2(5)
Next(ls,4)
# output
4×5 Matrix{Float64}:
 0.0   0.0   0.0   0.0   0.0
 0.5   0.5   0.5   0.5   0.5
 0.25  0.25  0.25  0.25  0.25
 0.75  0.75  0.75  0.75  0.75</code></pre><pre><code class="language-julia hljs">Next(ls,4)
# output
4×5 Matrix{Float64}:
 0.125  0.625  0.125  0.625  0.625
 0.625  0.125  0.625  0.125  0.125
 0.375  0.875  0.375  0.875  0.875
 0.875  0.375  0.875  0.375  0.375</code></pre><pre><code class="language-julia hljs">Reset!(ls)
# output</code></pre><h3 id="Independent-Sequence-Randomizations"><a class="docs-heading-anchor" href="#Independent-Sequence-Randomizations">Independent Sequence Randomizations</a><a id="Independent-Sequence-Randomizations-1"></a><a class="docs-heading-anchor-permalink" href="#Independent-Sequence-Randomizations" title="Permalink"></a></h3><p>Getting a single randomization was shown in the <a href="#Common-Usage">Common Usage</a> section. Support is also available for multiple independent randomizations. For instance, we can generating 2 independent randomizations with seed 11 and get the next 4 points in each sequence via  </p><pre><code class="language-julia hljs">rds = RandomDigitalShift(ds,2,11)
xs = NextR(rds,4)
typeof(xs)
# output
Vector{Matrix{Float64}} (alias for Array{Array{Float64, 2}, 1})</code></pre><pre><code class="language-julia hljs">xs[1]
# output
4×5 Matrix{Float64}:
 0.58051    0.862848  0.861659  0.919821  0.35264
 0.0805097  0.362848  0.361659  0.419821  0.85264
 0.33051    0.612848  0.611659  0.669821  0.60264
 0.83051    0.112848  0.111659  0.169821  0.10264</code></pre><pre><code class="language-julia hljs">xs[2]
# output
4×5 Matrix{Float64}:
 0.714139  0.702579  0.0130147  0.901326  0.280776
 0.214139  0.202579  0.513015   0.401326  0.780776
 0.464139  0.952579  0.263015   0.651326  0.530776
 0.964139  0.452579  0.763015   0.151326  0.0307758</code></pre><p>As with unrandomized sequences, we can get the next 4 points and then reset the generator with </p><pre><code class="language-julia hljs">xs = NextR(rds,4)
xs[1]
# output
4×5 Matrix{Float64}:
 0.95551  0.737848  0.486659  0.0448206  0.22764
 0.45551  0.237848  0.986659  0.544821   0.72764
 0.20551  0.987848  0.236659  0.294821   0.97764
 0.70551  0.487848  0.736659  0.794821   0.47764</code></pre><pre><code class="language-julia hljs">xs[2]
# output
4×5 Matrix{Float64}:
 0.839139   0.827579   0.638015  0.0263257  0.155776
 0.339139   0.327579   0.138015  0.526326   0.655776
 0.0891388  0.577579   0.888015  0.276326   0.905776
 0.589139   0.0775787  0.388015  0.776326   0.405776</code></pre><pre><code class="language-julia hljs">Reset!(rds)
# output</code></pre><p>Similarly for Lattices </p><pre><code class="language-julia hljs">rls = RandomShift(ls,2,11)
xr = NextR(rls,4)
xr[1]
# output
4×5 Matrix{Float64}:
 0.498434  0.26454    0.676602  0.46979  0.677608
 0.998434  0.76454    0.176602  0.96979  0.177608
 0.748434  0.51454    0.926602  0.71979  0.927608
 0.248434  0.0145404  0.426602  0.21979  0.427608</code></pre><pre><code class="language-julia hljs">xr[2]
# output
4×5 Matrix{Float64}:
 0.389721  0.719424  0.184079  0.568002   0.105514
 0.889721  0.219424  0.684079  0.0680019  0.605514
 0.639721  0.969424  0.434079  0.818002   0.355514
 0.139721  0.469424  0.934079  0.318002   0.855514</code></pre><pre><code class="language-julia hljs">Reset!(rls)
# output</code></pre><h2 id="Advanced-Features"><a class="docs-heading-anchor" href="#Advanced-Features">Advanced Features</a><a id="Advanced-Features-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-Features" title="Permalink"></a></h2><h3 id="Alternative-Generating-Matrices-and-Vectors"><a class="docs-heading-anchor" href="#Alternative-Generating-Matrices-and-Vectors">Alternative Generating Matrices and Vectors</a><a id="Alternative-Generating-Matrices-and-Vectors-1"></a><a class="docs-heading-anchor-permalink" href="#Alternative-Generating-Matrices-and-Vectors" title="Permalink"></a></h3><h4 id="Pregenerated"><a class="docs-heading-anchor" href="#Pregenerated">Pregenerated</a><a id="Pregenerated-1"></a><a class="docs-heading-anchor-permalink" href="#Pregenerated" title="Permalink"></a></h4><p>We include many alternative generating matrices for digital sequences in <a href="https://bitbucket.org/dnuyens/qmc-generators/src/master/DIGSEQ/">this directory</a>. To use an alternative, simply supply the relative path </p><pre><code class="language-julia hljs">ds = DigitalSeqB2G(3,&quot;sobolmats/sobol_alpha2_Bs64.col&quot;)
Next(ds,4)
# output
4×3 Matrix{Float64}:
 0.0     0.0     0.0
 0.75    0.75    0.75
 0.6875  0.1875  0.9375
 0.4375  0.9375  0.1875</code></pre><p>Alternative Lattice generating vectors are available in <a href="https://bitbucket.org/dnuyens/qmc-generators/src/master/LATSEQ/">this directory</a>. For Lattices, after supplying the path you also need to pass the <span>$m$</span> value in the file name</p><pre><code class="language-julia hljs">ls = LatticeSeqB2(3,&quot;exod8_base2_m13.txt&quot;,13)
Next(ls,4)
# output
4×3 Matrix{Float64}:
 0.0   0.0   0.0
 0.5   0.5   0.5
 0.25  0.25  0.75
 0.75  0.75  0.25</code></pre><h4 id="User-Defined"><a class="docs-heading-anchor" href="#User-Defined">User Defined</a><a id="User-Defined-1"></a><a class="docs-heading-anchor-permalink" href="#User-Defined" title="Permalink"></a></h4><p>One may supply their own generating matrix to construct a base 2 digital sequence, for example</p><pre><code class="language-julia hljs">m = 5
C1 = [BigInt(2^i) for i=0:(m-1)]
C2 = [BigInt(1) for i=1:m]
for i in 2:m C2[i] = (C2[i-1] &lt;&lt; 1) ⊻ C2[i-1] end
generating_matrix = vcat(C1&#39;,C2&#39;)
# output
2×5 Matrix{BigInt}:
 1  2  4   8  16
 1  3  5  15  17</code></pre><pre><code class="language-julia hljs">ds = DigitalSeqB2G(2,generating_matrix)
Next(ds,4)
# output
4×2 Matrix{Float64}:
 0.0   0.0
 0.5   0.5
 0.75  0.25
 0.25  0.75</code></pre><p>For base 2 Lattices, you may supply the generating vector followed by <span>$m$</span> where <span>$2^m$</span> is the maximum number of supported points </p><pre><code class="language-julia hljs">generating_vector = BigInt[1,433461,315689]
m = 20
ls = LatticeSeqB2(3,generating_vector,m)
Next(ls,4)
# output
4×3 Matrix{Float64}:
 0.0   0.0   0.0
 0.5   0.5   0.5
 0.25  0.25  0.25
 0.75  0.75  0.75</code></pre><h3 id="Linear-Ordering"><a class="docs-heading-anchor" href="#Linear-Ordering">Linear Ordering</a><a id="Linear-Ordering-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-Ordering" title="Permalink"></a></h3><p>By default, digital sequences are generated in Gray code order. One may generate the first <span>$2^m$</span> points in linear order via </p><pre><code class="language-julia hljs">m = 3
n = 2^m
ds = DigitalSeqB2G(4)
FirstLinear(ds,m)
# output
8×4 Matrix{Float64}:
 0.0    0.0    0.0    0.0
 0.5    0.5    0.5    0.5
 0.25   0.75   0.75   0.75
 0.75   0.25   0.25   0.25
 0.125  0.625  0.375  0.125
 0.625  0.125  0.875  0.625
 0.375  0.375  0.625  0.875
 0.875  0.875  0.125  0.375</code></pre><p>Compare to the original ordering </p><pre><code class="language-julia hljs">Next(ds,n)
# output
8×4 Matrix{Float64}:
 0.0    0.0    0.0    0.0
 0.5    0.5    0.5    0.5
 0.75   0.25   0.25   0.25
 0.25   0.75   0.75   0.75
 0.375  0.375  0.625  0.875
 0.875  0.875  0.125  0.375
 0.625  0.125  0.875  0.625
 0.125  0.625  0.375  0.125</code></pre><p>Similarly, Lattices are by default generated in extensible ordering. A linear ordering is also available </p><pre><code class="language-julia hljs">m = 3
n = 2^m 
ls = LatticeSeqB2(4)
FirstLinear(ls,m)
# output
8×4 Matrix{Float64}:
 0.0    0.0    0.0    0.0
 0.125  0.625  0.125  0.625
 0.25   0.25   0.25   0.25
 0.375  0.875  0.375  0.875
 0.5    0.5    0.5    0.5
 0.625  0.125  0.625  0.125
 0.75   0.75   0.75   0.75
 0.875  0.375  0.875  0.375</code></pre><p>Compare to the original ordering </p><pre><code class="language-julia hljs">Next(ls,n)
# output
8×4 Matrix{Float64}:
 0.0    0.0    0.0    0.0
 0.5    0.5    0.5    0.5
 0.25   0.25   0.25   0.25
 0.75   0.75   0.75   0.75
 0.125  0.625  0.125  0.625
 0.625  0.125  0.625  0.125
 0.375  0.875  0.375  0.875
 0.875  0.375  0.875  0.375</code></pre><p>Linear order for randomized sequences has expected syntax </p><pre><code class="language-julia hljs">ds = DigitalSeqB2G(4)
rds = RandomDigitalShift(ds,1,17)
FirstLinear(rds,2)
# output
4×4 Matrix{Float64}:
 0.844967   0.66901  0.686087  0.362606
 0.344967   0.16901  0.186087  0.862606
 0.594967   0.41901  0.436087  0.612606
 0.0949675  0.91901  0.936087  0.112606</code></pre><pre><code class="language-julia hljs">rds = RandomDigitalShift(ds,2,17)
xs = FirstRLinear(rds,2)
xs[1]
# output
4×4 Matrix{Float64}:
 0.844967   0.686087  0.936228  0.96835
 0.344967   0.186087  0.436228  0.46835
 0.594967   0.436087  0.186228  0.21835
 0.0949675  0.936087  0.686228  0.71835</code></pre><pre><code class="language-julia hljs">xs[2]
# output
4×4 Matrix{Float64}:
 0.66901  0.362606  0.532599   0.347617
 0.16901  0.862606  0.0325994  0.847617
 0.91901  0.612606  0.282599   0.597617
 0.41901  0.112606  0.782599   0.0976169</code></pre><p>The same functions are available for randomly shifted lattices. </p><h3 id="Binary-Functions-for-Digital-Sequences"><a class="docs-heading-anchor" href="#Binary-Functions-for-Digital-Sequences">Binary Functions for Digital Sequences</a><a id="Binary-Functions-for-Digital-Sequences-1"></a><a class="docs-heading-anchor-permalink" href="#Binary-Functions-for-Digital-Sequences" title="Permalink"></a></h3><p>For digital sequences, we sometimes want the binary representation of points. We can get the binary representations as integers and then convert them to their floating point values as follows </p><pre><code class="language-julia hljs">ds = DigitalSeqB2G(4)
xb = NextBinary(ds,4)
# output
4×4 Matrix{BigInt}:
          0           0           0           0
 2147483648  2147483648  2147483648  2147483648
 3221225472  1073741824  1073741824  1073741824
 1073741824  3221225472  3221225472  3221225472</code></pre><pre><code class="language-julia hljs">BinaryToFloat64(xb,ds)
# output
4×4 Matrix{Float64}:
 0.0   0.0   0.0   0.0
 0.5   0.5   0.5   0.5
 0.75  0.25  0.25  0.25
 0.25  0.75  0.75  0.75</code></pre><p>This is also compatible with randomized digital sequences </p><pre><code class="language-julia hljs">Reset!(ds)
rds_single = RandomDigitalShift(ds,1,11)
xb = NextBinary(rds_single,4)
# output
4×4 Matrix{BigInt}:
 5228766587057444  6432390138047189  7771840027009430  6328265944608255
  725166959686948  1928790510676693  3268240399638934  1824666317237759
 2976966773372196  8684189951732437  5520040213324182  8580065758293503
 7480566400742692  4180590324361941  1016440585953686  4076466130923007</code></pre><pre><code class="language-julia hljs">BinaryToFloat64(xb,rds_single)
# output
4×4 Matrix{Float64}:
 0.58051    0.714139  0.862848  0.702579
 0.0805097  0.214139  0.362848  0.202579
 0.33051    0.964139  0.612848  0.952579
 0.83051    0.464139  0.112848  0.452579</code></pre><pre><code class="language-julia hljs">Reset!(ds)
rds_multiple = RandomDigitalShift(ds,2,11)
xbs = NextRBinary(rds_multiple,4)
xbs[1]
# output
4×4 Matrix{BigInt}:
 5228766587057444  7771840027009430  7761130250550079  8285007185180178
  725166959686948  3268240399638934  3257530623179583  3781407557809682
 2976966773372196  5520040213324182  5509330436864831  6033207371494930
 7480566400742692  1016440585953686  1005730809494335  1529607744124434</code></pre><pre><code class="language-julia hljs">xbs[2]
# output
4×4 Matrix{BigInt}:
 6432390138047189  6328265944608255   117225724257639  8118420346456289
 1928790510676693  1824666317237759  4620825351628135  3614820719085793
 4180590324361941  8580065758293503  2369025537942887  5866620532771041
 8684189951732437  4076466130923007  6872625165313383  1363020905400545</code></pre><pre><code class="language-julia hljs">BinaryToFloat64(xbs,rds_multiple)</code></pre><p>Getting binary points with linear ordering is also supported. </p><pre><code class="language-julia hljs">Reset!(ds) # resets rds_single and rds_multiple as well
FirstLinearBinary(ds,2)
# output
4×4 Matrix{BigInt}:
          0           0           0           0
 2147483648  2147483648  2147483648  2147483648
 1073741824  3221225472  3221225472  3221225472
 3221225472  1073741824  1073741824  1073741824</code></pre><pre><code class="language-julia hljs">FirstLinearBinary(rds_single,2)
# output
4×4 Matrix{BigInt}:
 5228766587057444  6432390138047189  7771840027009430  6328265944608255
  725166959686948  1928790510676693  3268240399638934  1824666317237759
 7480566400742692  4180590324361941  1016440585953686  4076466130923007
 2976966773372196  8684189951732437  5520040213324182  8580065758293503</code></pre><pre><code class="language-julia hljs">xbs = FirstRLinearBinary(rds_multiple,2)
xbs[1]
# output
4×4 Matrix{BigInt}:
 5228766587057444  7771840027009430  7761130250550079  8285007185180178
  725166959686948  3268240399638934  3257530623179583  3781407557809682
 7480566400742692  1016440585953686  1005730809494335  1529607744124434
 2976966773372196  5520040213324182  5509330436864831  6033207371494930</code></pre><pre><code class="language-julia hljs">xbs[2]
# output
4×4 Matrix{BigInt}:
 6432390138047189  6328265944608255   117225724257639  8118420346456289
 1928790510676693  1824666317237759  4620825351628135  3614820719085793
 8684189951732437  4076466130923007  6872625165313383  1363020905400545
 4180590324361941  8580065758293503  2369025537942887  5866620532771041</code></pre><p>These may be converted to floats as before. </p><h3 id="IID-Standard-Uniform-Generator"><a class="docs-heading-anchor" href="#IID-Standard-Uniform-Generator">IID Standard Uniform Generator</a><a id="IID-Standard-Uniform-Generator-1"></a><a class="docs-heading-anchor-permalink" href="#IID-Standard-Uniform-Generator" title="Permalink"></a></h3><p>We provide an IID <span>$\mathcal{U}[0,1]^s$</span> generator with the same API as Lattice and digital sequences. This is a wrapper around <a href="https://docs.julialang.org/en/v1/stdlib/Random/#Random.MersenneTwister"><code>Random.MersenneTwister</code></a>.</p><p>For reproducibility, you may provide a seed.</p><pre><code class="language-julia hljs">iiduseq = IIDU01Seq(3,7)
Next(iiduseq,4)
# output
4×3 Matrix{Float64}:
 0.812439   0.654977  0.489613
 0.0787595  0.581591  0.258053
 0.196465   0.193925  0.842951
 0.66193    0.401352  0.635904</code></pre><pre><code class="language-julia hljs">Reset!(iiduseq)
Next(iiduseq,4)
# output
4×3 Matrix{Float64}:
 0.812439   0.654977  0.489613
 0.0787595  0.581591  0.258053
 0.196465   0.193925  0.842951
 0.66193    0.401352  0.635904</code></pre><p>The seed gets used to construct a <code>MersenneTwister</code>. After</p><pre><code class="language-julia hljs">using Random: MersenneTwister</code></pre><p>You may pass also pass a <code>MersenneTwister</code> instance directly.</p><pre><code class="language-julia hljs">iiduseq = IIDU01Seq(3,MersenneTwister(7))
Next(iiduseq,4)
# output
4×3 Matrix{Float64}:
 0.812439   0.654977  0.489613
 0.0787595  0.581591  0.258053
 0.196465   0.193925  0.842951
 0.66193    0.401352  0.635904</code></pre><p>Providing neither a seed nor <code>MersenneTwister</code> uses <code>MersenneTwister()</code>.</p><pre><code class="language-julia hljs">iiduseq = IIDU01Seq(3)
size(Next(iiduseq,4))
# output
(4, 3)</code></pre><h2 id="Plotting"><a class="docs-heading-anchor" href="#Plotting">Plotting</a><a id="Plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting" title="Permalink"></a></h2><p>To save figures we need to ensure we are</p><pre><code class="language-julia hljs">using CairoMakie</code></pre><h3 id="Single-Projection"><a class="docs-heading-anchor" href="#Single-Projection">Single Projection</a><a id="Single-Projection-1"></a><a class="docs-heading-anchor-permalink" href="#Single-Projection" title="Permalink"></a></h3><pre><code class="language-julia hljs">PLOTDIR = joinpath(@__DIR__,&quot;src/assets&quot;)
n = 2^6
ds = DigitalSeqB2G(3)
fig = qmcscatter!(ds,n)
save(joinpath(PLOTDIR,&quot;basic.svg&quot;),fig)</code></pre><p><img src="../assets/basic.svg" alt="image"/></p><h3 id="Extensibility"><a class="docs-heading-anchor" href="#Extensibility">Extensibility</a><a id="Extensibility-1"></a><a class="docs-heading-anchor-permalink" href="#Extensibility" title="Permalink"></a></h3><pre><code class="language-julia hljs">nvec = [1,2^6,2^7,2^8]
fig = qmcscatter!(ds,nvec)
save(joinpath(PLOTDIR,&quot;extensibility.svg&quot;),fig)</code></pre><p><img src="../assets/extensibility.svg" alt="image"/></p><h3 id="Multiple-Projections"><a class="docs-heading-anchor" href="#Multiple-Projections">Multiple Projections</a><a id="Multiple-Projections-1"></a><a class="docs-heading-anchor-permalink" href="#Multiple-Projections" title="Permalink"></a></h3><pre><code class="language-julia hljs">dvec = [1 2; 1 3; 2 3]
fig = qmcscatter!(ds,nvec,dvec)
save(joinpath(PLOTDIR,&quot;projections.svg&quot;),fig)</code></pre><p><img src="../assets/projections.svg" alt="image"/></p><h3 id="Multiple-Randomizations"><a class="docs-heading-anchor" href="#Multiple-Randomizations">Multiple Randomizations</a><a id="Multiple-Randomizations-1"></a><a class="docs-heading-anchor-permalink" href="#Multiple-Randomizations" title="Permalink"></a></h3><pre><code class="language-julia hljs">rds = RandomDigitalShift(DigitalSeqB2G(3),3)
fig = qmcscatter!(rds,nvec,dvec)
save(joinpath(PLOTDIR,&quot;randomizations.svg&quot;),fig)</code></pre><p><img src="../assets/randomizations.svg" alt="image"/></p><h3 id="Comparison-of-Sequences"><a class="docs-heading-anchor" href="#Comparison-of-Sequences">Comparison of Sequences</a><a id="Comparison-of-Sequences-1"></a><a class="docs-heading-anchor-permalink" href="#Comparison-of-Sequences" title="Permalink"></a></h3><pre><code class="language-julia hljs">iid = IIDU01Seq(3)
rds = RandomDigitalShift(DigitalSeqB2G(3))
rls = RandomShift(LatticeSeqB2(3))
fig = qmcscatter!([1,2^6,2^7,2^8],[1 2],iid=iid,rds=rds,rls=rls)
save(joinpath(PLOTDIR,&quot;seq_comparison.svg&quot;),fig)</code></pre><p><img src="../assets/seq_comparison.svg" alt="image"/></p><h3 id="MC-vs-QMC"><a class="docs-heading-anchor" href="#MC-vs-QMC">MC vs QMC</a><a id="MC-vs-QMC-1"></a><a class="docs-heading-anchor-permalink" href="#MC-vs-QMC" title="Permalink"></a></h3><p>We also need to be </p><pre><code class="language-julia hljs">using Distributions
using LinearAlgebra</code></pre><pre><code class="language-julia hljs">m = 16
r = 100
seed = 7
n = 2^m
s,mu = 7,-11.05684907978818
rseqs = [IIDU01Seq(s,seed),RandomShift(LatticeSeqB2(s),r,seed),RandomDigitalShift(DigitalSeqB2G(s),r,seed)]
xsets = [
    [Next(rseqs[1],n) for k=1:r],
    NextR(rseqs[2],n),
    NextR(rseqs[3],n)]
f(x::Vector{Float64}) = π^(s/2)*cos(norm(quantile.(Normal(),x)/sqrt(2)));
f(x::Matrix{Float64}) = map(i-&gt;f(x[i,:]),1:size(x,1))
fig = Figure(resolution=(800,500))
ax = Axis(fig[2,1],
    xlabel = L&quot;$n$&quot;,
    ylabel = L&quot;$| \hat{\mu} - \mu |$&quot;,
    yscale = log10,
    xscale = log2)
xlims!(ax,[1,n])
for k=1:size(xsets,1)
    name,xs = rseqs[k].name,xsets[k]
    ys = vcat(map(i-&gt;f(xs[i]),1:r)&#39;...)
    muhats = cumsum(ys,dims=2); for i=1:r muhats[i,:] = muhats[i,:]./[i for i=1:n] end 
    err = abs.(muhats.-mu)
    pows2 = 2 .^ (0:m)
    qlowerr = map(p2-&gt;quantile(err[:,p2],.35),pows2)
    qmid = map(p2-&gt;quantile(err[:,p2],.5),pows2)
    qhigherr = map(p2-&gt;quantile(err[:,p2],.65),pows2)
    lines!(ax,pows2,qmid,color=JULIA4LOGOCOLORS[k],label=name,linewidth=3)
    band!(pows2,qhigherr,qlowerr,color=(JULIA4LOGOCOLORS[k],.3))
end
fig[1,1] = Legend(fig,ax,framevisible=false,orientation=:horizontal)
hidespines!(ax, :t, :r)
save(joinpath(PLOTDIR,&quot;mc_vs_qmc.svg&quot;),fig)</code></pre><p><img src="../assets/mc_vs_qmc.svg" alt="image"/></p><h3 id="Logo"><a class="docs-heading-anchor" href="#Logo">Logo</a><a id="Logo-1"></a><a class="docs-heading-anchor-permalink" href="#Logo" title="Permalink"></a></h3><pre><code class="language-julia hljs">nvec = [1,4,16,64]
rds = RandomOwenScramble(DigitalSeqB2G(2),1,17)
x = Next(rds,maximum(nvec))
fig = Figure(resolution=(500,500),backgroundcolor=:transparent)
ax = Axis(fig[1,1],aspect=1,xticklabelsvisible=false,yticklabelsvisible=false,backgroundcolor=:transparent)
qmcscatter!(ax,x,nvec)
limits!(ax,[-0.01,1.01],[-0.01,1.01])
for i=1:7 vlines!(ax,i/8,color=JULIA4LOGOCOLORS[3],alpha=1); hlines!(ax,i/8,color=JULIA4LOGOCOLORS[3],alpha=1) end 
for i=1:3 vlines!(ax,i/4,color=JULIA4LOGOCOLORS[2],alpha=1); hlines!(ax,i/4,color=JULIA4LOGOCOLORS[2],alpha=1) end 
for i=1:1 vlines!(ax,i/2,color=JULIA4LOGOCOLORS[1],alpha=1); hlines!(ax,i/2,color=JULIA4LOGOCOLORS[1],alpha=1) end 
hidespines!(ax); hidedecorations!(ax); hidexdecorations!(ax,grid = false); hideydecorations!(ax, ticks = false)
save(joinpath(PLOTDIR,&quot;logo.svg&quot;),fig)</code></pre><p><img src="../assets/logo.svg" alt="image"/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Friday 21 July 2023 17:05">Friday 21 July 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
