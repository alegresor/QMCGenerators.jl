var documenterSearchIndex = {"docs":
[{"location":"#Quasi-Monte-Carlo-Generators","page":"Home","title":"Quasi-Monte Carlo Generators","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julia version of Dirk Nuyens' Magic Point Shop. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the Tutorial for instructions on how to use this package.  ","category":"page"},{"location":"#Quasi-Random-Generators","page":"Home","title":"Quasi-Random Generators","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"QMCGenerators.jl implements quasi-random (low discrepancy) sequence generators. Quasi-random points are carefully coordinated in a dependent manner to more evenly fill 01^s compared to pseudo-random (independent) points. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package implements two flavors of quasi-random sequences: lattice rules and digital nets, both in base 2. Independent randomizations may be applied to base sequences via random shifts for lattices and either random digital shifts, random linear matrix scrambles, and/or random Owen scrambles for digital nets.  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: image)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Notice the gaps and clusters of the above pseudo-random points compared to the more even coverage of quasi-random points. The implemented quasi-random sequences are extensible, meaning you may increase the sample size through powers of two to better fill the space. Above, each plot starts with 2^6 blue points. Doubling the sample size to 2^7 adds the green points. Doubling again to 2^8 samples adds the purple points. ","category":"page"},{"location":"#Quasi-Monte-Carlo","page":"Home","title":"Quasi-Monte Carlo","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Monte Carlo methods approximate the true mean","category":"page"},{"location":"","page":"Home","title":"Home","text":"mu = mathbbEf(X) = int_01^s f(x) mathrmd x","category":"page"},{"location":"","page":"Home","title":"Home","text":"for f 01^s to mathbbR and X sim mathcalU01^s by the sample mean","category":"page"},{"location":"","page":"Home","title":"Home","text":"hatmu = frac1n sum_i=0^n-1 f(X_i)","category":"page"},{"location":"","page":"Home","title":"Home","text":"where X_0X_1dots sim mathcalU01^s. If X_i are chosen to be pseudo-random, then the sample average is a Simple Monte Carlo approximation with error mathcalO(n^-12). If instead we choose X_i to be quasi-random then the sample average is a Quasi-Monte Carlo approximation with error approaching mathcalO(n^-1). ","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: image)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The above example approximates mu = mathbbEg(T) where g mathbbR^s to mathbbR is the Keister function","category":"page"},{"location":"","page":"Home","title":"Home","text":"g(t) = pi^s2 cos( lVert t rVert_2)","category":"page"},{"location":"","page":"Home","title":"Home","text":"and T sim mathcalN(0I_s2)  in dimension s=7. To make this Quasi-Monte Carlo compatible, we set ","category":"page"},{"location":"","page":"Home","title":"Home","text":"f(x) = g(Phi^-1(x)sqrt2)","category":"page"},{"location":"","page":"Home","title":"Home","text":"where Phi^-1 is the inverse CDF of mathcalN(01) applied elementwise. This transform satisfies","category":"page"},{"location":"","page":"Home","title":"Home","text":"mu = mathbbEf(X) = mathbbEg(T)","category":"page"},{"location":"","page":"Home","title":"Home","text":"where X sim mathcalU01^s as desired. ","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Kuo, F. Y., & Nuyens, D. (2016). Application of quasi-Monte Carlo methods to elliptic PDEs with random diffusion coefficients: a survey of analysis and implementation. Foundations of Computational Mathematics, 16, 1631-1696.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"DocTestSetup = quote\n    using QMCGenerators\n    using CairoMakie\n    using Random: MersenneTwister\n    using Distributions\n    using LinearAlgebra\nend","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Pages = [\"tutorial.md\"]\nDepth = 4","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To begin, install this package with ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Pkg.add(\"QMCGenerators\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"and then import via","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using QMCGenerators","category":"page"},{"location":"tutorial/#Common-Usage","page":"Tutorial","title":"Common Usage","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Often we just want to generate a single randomized quasi-random sequence. For example, to generate the first 4 points of a 3 dimensional lattice with 1 random shift with seed 7","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Next(RandomShift(LatticeSeqB2(3),1,7),4)\n# output\n4×3 Matrix{Float64}:\n 0.243795  0.719182  0.810814\n 0.743795  0.219182  0.310814\n 0.993795  0.469182  0.560814\n 0.493795  0.969182  0.0608139","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"A similar API is available for digital sequences with an additional seed 11 for the linear matrix scrambling","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Next(RandomDigitalShift(DigitalSeqB2G(LinearMatrixScramble(3,11)),1,7),4)\n# output\n4×3 Matrix{Float64}:\n 0.243795  0.719182   0.810814\n 0.771201  0.0243044  0.295548\n 0.681966  0.909305   0.629735\n 0.33425   0.339548   0.144758","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"warning: Warning\nWhile not strictly enforced, sample sizes should be powers of two to achieve full coverage of 01^s","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In the following sections we always supply a seed for reproducibility. Supplying a seed requires you also supply the number of randomizations as done above. However, if you do not wish to seed, you can simply supply the number of randomizations. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"rls = RandomShift(LatticeSeqB2(12),2)\nxs = NextR(rls,2^7)\nsize(xs)\n# output\n(2,)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"size(xs[1]) == size(xs[2]) == (2^7,12)\n# output\ntrue","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Moreover, you may use only one randomization without a seed with the simplified API","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"rls = RandomShift(LatticeSeqB2(52))\nx = Next(rls,2^14)\nsize(x)\n# output\n(16384, 52)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The same API simplifications holds for digital sequences  ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"rds = RandomDigitalShift(DigitalSeqB2G(LinearMatrixScramble(52)))\nx = Next(rds,2^14)\nsize(x)\n# output\n(16384, 52)","category":"page"},{"location":"tutorial/#Structure-and-Functions","page":"Tutorial","title":"Structure and Functions","text":"","category":"section"},{"location":"tutorial/#Unrandomized-Sequences","page":"Tutorial","title":"Unrandomized Sequences","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"warning: Warning\nIt is highly recommended you randomize sequences. The first point of an unrandomized sequence is 0 in 01^s which will be transformed to an infinite values in many functions e.g. those composed with taking the inverse CDF of a mathcalN(01) as done in the section on Quasi-Monte Carlo. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's start by defining a 5 dimensional (unrandomized) digital sequence and generating the first 4 points.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"ds = DigitalSeqB2G(5)\nNext(ds,4)\n# output\n4×5 Matrix{Float64}:\n 0.0   0.0   0.0   0.0   0.0\n 0.5   0.5   0.5   0.5   0.5\n 0.75  0.25  0.25  0.25  0.75\n 0.25  0.75  0.75  0.75  0.25","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can then generate the next 4 points in the sequence with ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Next(ds,4)\n# output\n4×5 Matrix{Float64}:\n 0.375  0.375  0.625  0.875  0.375\n 0.875  0.875  0.125  0.375  0.875\n 0.625  0.125  0.875  0.625  0.625\n 0.125  0.625  0.375  0.125  0.125","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To reset the generator use","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Reset!(ds)\nNext(ds,4)\n# output\n4×5 Matrix{Float64}:\n 0.0   0.0   0.0   0.0   0.0\n 0.5   0.5   0.5   0.5   0.5\n 0.75  0.25  0.25  0.25  0.75\n 0.25  0.75  0.75  0.75  0.25","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's reset once more before continuing ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Reset!(ds)\n# output","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"These functions can also be applied to lattices ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"ls = LatticeSeqB2(5)\nNext(ls,4)\n# output\n4×5 Matrix{Float64}:\n 0.0   0.0   0.0   0.0   0.0\n 0.5   0.5   0.5   0.5   0.5\n 0.75  0.75  0.75  0.75  0.75\n 0.25  0.25  0.25  0.25  0.25","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Next(ls,4)\n# output\n4×5 Matrix{Float64}:\n 0.875  0.375  0.875  0.375  0.375\n 0.625  0.125  0.625  0.125  0.125\n 0.375  0.875  0.375  0.875  0.875\n 0.125  0.625  0.125  0.625  0.625","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Reset!(ls)\n# output","category":"page"},{"location":"tutorial/#Randomized-Sequences","page":"Tutorial","title":"Randomized Sequences","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"A random shift may be applied to lattice sequences with the API shown in the Common Usage section.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Digital sequences have multiple randomization options available.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Owen's scrambling maximally randomizes a sequence, but is slow to compute. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"rds = RandomOwenScramble(DigitalSeqB2G(3),1,7)\nNext(rds,4)\n# output\n4×3 Matrix{Float64}:\n 0.346099  0.289927  0.564151\n 0.994684  0.621427  0.372878\n 0.698052  0.24576   0.977445\n 0.196841  0.88248   0.112319","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Digital shifts provide a less thorough randomization, but are very fast to compute.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"rds = RandomDigitalShift(DigitalSeqB2G(3),1,7)\nNext(rds,4)\n# output\n4×3 Matrix{Float64}:\n 0.243795  0.719182  0.810814\n 0.743795  0.219182  0.310814\n 0.993795  0.969182  0.560814\n 0.493795  0.469182  0.0608139","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Linear matrix scrambling with digital shifts provide a nice compromise in both randomization completeness and speed. This is the example shown in the Common Usage section. Owen scrambling with LMS is also available. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"rds = RandomOwenScramble(DigitalSeqB2G(LinearMatrixScramble(3,11)),1,7)\nNext(rds,4)\n# output\n4×3 Matrix{Float64}:\n 0.346099  0.289927  0.564151\n 0.53796   0.630151  0.357835\n 0.923417  0.192356  0.946886\n 0.170416  0.790742  0.0635345","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"warning: Warning\nLinear matrix scrambling randomizes the generating matrix but does not randomize the sequence. The first point of a digital sequence with LMS is still 0 in 01^s as shown in the following example. ds = DigitalSeqB2G(LinearMatrixScramble(3,11))\nNext(ds,4)\n# output\n4×3 Matrix{Float64}:\n 0.0       0.0       0.0\n 0.980533  0.742746  0.516488\n 0.566346  0.315742  0.432248\n 0.421756  0.933364  0.916494A digital shift or Owen scramble should be applied to the digital sequence with LMS in order to randomize the sequence. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Linear matrix scrambling is applied directly to the generating matrix of a digital sequence e.g. the following code applies an LMS to the first 3 dimensions of the default generating matrix with seed 11.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"rds = LinearMatrixScramble(3,11)\nrds.Csrlms[1:3,1:3]\n# output\n3×3 Matrix{UInt64}:\n 0x001f60869b738564  0x000d7f065de612f1  0x0006671047133f9f\n 0x0017c4931a760945  0x001dde1ef7348c8e  0x0013d32d59fa5f55\n 0x0010871136dcba91  0x001d53ebb82524d8  0x0009261aca2e1a0e","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"An explicit generating matrix or path to an existing generating matrix may also be supplied as discussed in the Alternative Generating Matrices and Vectors section. ","category":"page"},{"location":"tutorial/#Independent-Sequence-Randomizations","page":"Tutorial","title":"Independent Sequence Randomizations","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Getting a single randomization was shown in the Common Usage section. Support is also available for multiple independent randomizations. For instance, we can generating 2 independent randomizations with seed 11 and get the next 4 points in each sequence via  ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"ds = DigitalSeqB2G(5)\nrds = RandomDigitalShift(ds,2,11)\nxs = NextR(rds,4)\ntypeof(xs)\n# output\nVector{Matrix{Float64}} (alias for Array{Array{Float64, 2}, 1})","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"xs[1]\n# output\n4×5 Matrix{Float64}:\n 0.58051    0.862848  0.861659  0.919821  0.35264\n 0.0805097  0.362848  0.361659  0.419821  0.85264\n 0.33051    0.612848  0.611659  0.669821  0.60264\n 0.83051    0.112848  0.111659  0.169821  0.10264","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"xs[2]\n# output\n4×5 Matrix{Float64}:\n 0.714139  0.702579  0.0130147  0.901326  0.280776\n 0.214139  0.202579  0.513015   0.401326  0.780776\n 0.464139  0.952579  0.263015   0.651326  0.530776\n 0.964139  0.452579  0.763015   0.151326  0.0307758","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"As with unrandomized sequences, we can get the next 4 points and then reset the generator with ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"xs = NextR(rds,4)\nxs[1]\n# output\n4×5 Matrix{Float64}:\n 0.95551  0.737848  0.486659  0.0448206  0.22764\n 0.45551  0.237848  0.986659  0.544821   0.72764\n 0.20551  0.987848  0.236659  0.294821   0.97764\n 0.70551  0.487848  0.736659  0.794821   0.47764","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"xs[2]\n# output\n4×5 Matrix{Float64}:\n 0.839139   0.827579   0.638015  0.0263257  0.155776\n 0.339139   0.327579   0.138015  0.526326   0.655776\n 0.0891388  0.577579   0.888015  0.276326   0.905776\n 0.589139   0.0775787  0.388015  0.776326   0.405776","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Reset!(rds)\n# output","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Similarly for Lattices ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"rls = RandomShift(ls,2,11)\nxr = NextR(rls,4)\nxr[1]\n# output\n4×5 Matrix{Float64}:\n 0.498434  0.26454    0.676602  0.46979  0.677608\n 0.998434  0.76454    0.176602  0.96979  0.177608\n 0.248434  0.0145404  0.426602  0.21979  0.427608\n 0.748434  0.51454    0.926602  0.71979  0.927608","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"xr[2]\n# output\n4×5 Matrix{Float64}:\n 0.389721  0.719424  0.184079  0.568002   0.105514\n 0.889721  0.219424  0.684079  0.0680019  0.605514\n 0.139721  0.469424  0.934079  0.318002   0.855514\n 0.639721  0.969424  0.434079  0.818002   0.355514","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Reset!(rls)\n# output","category":"page"},{"location":"tutorial/#Advanced-Features","page":"Tutorial","title":"Advanced Features","text":"","category":"section"},{"location":"tutorial/#Alternative-Generating-Matrices-and-Vectors","page":"Tutorial","title":"Alternative Generating Matrices and Vectors","text":"","category":"section"},{"location":"tutorial/#Pregenerated","page":"Tutorial","title":"Pregenerated","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We support user defined generating matrices for digital sequences and lattice sequences in the formats specified by the LDData repository. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For digital sequences, you may supply a path to a local file or a relative path from https://github.com/QMCSoftware/LDData/tree/main/dnet as shown below","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"ds = DigitalSeqB2G(3,\"mps.sobol_alpha2_Bs64.txt\")\nNext(ds,4)\n# output\n4×3 Matrix{Float64}:\n 0.0     0.0     0.0\n 0.75    0.75    0.75\n 0.6875  0.1875  0.9375\n 0.4375  0.9375  0.1875","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Linear matrix scrambling also accepts these paths ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"ds = DigitalSeqB2G(LinearMatrixScramble(3,\"mps.sobol_alpha2_Bs64.txt\",11))\nNext(ds,4)\n# output\n4×3 Matrix{Float64}:\n 0.0       0.0       0.0\n 0.566346  0.78024   0.688634\n 0.814588  0.235829  0.545582\n 0.251783  0.983926  0.233902","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For lattice sequences, you may supply a path to a local file or a relative path from https://github.com/QMCSoftware/LDData/tree/main/lattice as shown below","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"ls = LatticeSeqB2(3,\"mps.exod8_base2_m13.txt\")\nNext(ls,4)\n# output\n4×3 Matrix{Float64}:\n 0.0   0.0   0.0\n 0.5   0.5   0.5\n 0.75  0.75  0.25\n 0.25  0.25  0.75","category":"page"},{"location":"tutorial/#User-Defined","page":"Tutorial","title":"User Defined","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For digital sequences, you may supply the generating matrix followed by t where t is the number of bits in each integer representations","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"t = 5\ngenerating_matrix = Matrix{BigInt}([16 8 4 2 1; 16 24 20 30 17])\nds = DigitalSeqB2G(2,generating_matrix,t)\nNext(ds,4)\n# output\n4×2 Matrix{Float64}:\n 0.0   0.0\n 0.5   0.5\n 0.75  0.25\n 0.25  0.75","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Linear matrix scrambling also accommodates such constructions ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"ds = DigitalSeqB2G(LinearMatrixScramble(2,generating_matrix,t,11))\nNext(ds,4)\n# output\n4×2 Matrix{Float64}:\n 0.0       0.0\n 0.980533  0.742746\n 0.566346  0.315742\n 0.421756  0.933364","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For base 2 Lattices, you may supply the generating vector followed by m where 2^m is the maximum number of supported points ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"generating_vector = BigInt[1,433461,315689]\nm = 20\nls = LatticeSeqB2(3,generating_vector,m)\nNext(ls,4)\n# output\n4×3 Matrix{Float64}:\n 0.0   0.0   0.0\n 0.5   0.5   0.5\n 0.75  0.75  0.75\n 0.25  0.25  0.25","category":"page"},{"location":"tutorial/#Linear-Ordering","page":"Tutorial","title":"Linear Ordering","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"By default, digital sequences are generated in Gray code order. One may generate the first 2^m points in linear order via ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"m = 3\nn = 2^m\nds = DigitalSeqB2G(4)\nFirstLinear(ds,m)\n# output\n8×4 Matrix{Float64}:\n 0.0    0.0    0.0    0.0\n 0.5    0.5    0.5    0.5\n 0.25   0.75   0.75   0.75\n 0.75   0.25   0.25   0.25\n 0.125  0.625  0.375  0.125\n 0.625  0.125  0.875  0.625\n 0.375  0.375  0.625  0.875\n 0.875  0.875  0.125  0.375","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Compare to the original ordering ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Next(ds,n)\n# output\n8×4 Matrix{Float64}:\n 0.0    0.0    0.0    0.0\n 0.5    0.5    0.5    0.5\n 0.75   0.25   0.25   0.25\n 0.25   0.75   0.75   0.75\n 0.375  0.375  0.625  0.875\n 0.875  0.875  0.125  0.375\n 0.625  0.125  0.875  0.625\n 0.125  0.625  0.375  0.125","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Similarly, Lattices are by default generated in extensible ordering. A linear ordering is also available ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"m = 3\nn = 2^m \nls = LatticeSeqB2(4)\nFirstLinear(ls,m)\n# output\n8×4 Matrix{Float64}:\n 0.0    0.0    0.0    0.0\n 0.125  0.625  0.125  0.625\n 0.25   0.25   0.25   0.25\n 0.375  0.875  0.375  0.875\n 0.5    0.5    0.5    0.5\n 0.625  0.125  0.625  0.125\n 0.75   0.75   0.75   0.75\n 0.875  0.375  0.875  0.375","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Compare to the original ordering ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Next(ls,n)\n# output\n8×4 Matrix{Float64}:\n 0.0    0.0    0.0    0.0\n 0.5    0.5    0.5    0.5\n 0.75   0.75   0.75   0.75\n 0.25   0.25   0.25   0.25\n 0.875  0.375  0.875  0.375\n 0.625  0.125  0.625  0.125\n 0.375  0.875  0.375  0.875\n 0.125  0.625  0.125  0.625","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Linear order for randomized sequences has expected syntax ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"ds = DigitalSeqB2G(LinearMatrixScramble(4,11))\nrds = RandomDigitalShift(ds,1,17)\nFirstLinear(rds,2)\n# output\n4×4 Matrix{Float64}:\n 0.844967  0.66901    0.686087  0.362606\n 0.137878  0.0835059  0.170347  0.651575\n 0.702026  0.27229    0.270447  0.917505\n 0.283993  0.982671   0.753976  0.0663986","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"rds = RandomDigitalShift(ds,2,17)\nxs = FirstRLinear(rds,2)\nxs[1]\n# output\n4×4 Matrix{Float64}:\n 0.844967  0.686087   0.936228   0.96835\n 0.137878  0.0684781  0.420229   0.054624\n 0.702026  0.255183   0.0203245  0.257201\n 0.283993  0.997912   0.504081   0.73355","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"xs[2]\n# output\n4×4 Matrix{Float64}:\n 0.66901   0.362606   0.532599   0.347617\n 0.313478  0.886583   0.0483536  0.636283\n 0.752869  0.695851   0.385852   0.932851\n 0.23328   0.0469946  0.90234    0.081319","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"rds = RandomOwenScramble(ds,2,17)\nxs = FirstRLinear(rds,2)\nxs[1]\n# output\n4×4 Matrix{Float64}:\n 0.470887  0.479045  0.799276  0.441699\n 0.580069  0.906795  0.139574  0.886189\n 0.180755  0.541936  0.357921  0.644701\n 0.968294  0.175449  0.570342  0.183857","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"xs[2]\n# output\n4×4 Matrix{Float64}:\n 0.392039  0.407401   0.181603  0.109236\n 0.812677  0.683277   0.991765  0.882639\n 0.151533  0.86366    0.620386  0.668969\n 0.583849  0.0445951  0.385324  0.340111","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For lattices a similar API holds","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"rls = RandomShift(LatticeSeqB2(4),2,17)\nxs = FirstRLinear(rls,2)\nxs[1]\n# output\n4×4 Matrix{Float64}:\n 0.447971  0.593933   0.190141  0.331784\n 0.697971  0.843933   0.440141  0.581784\n 0.947971  0.0939328  0.690141  0.831784\n 0.197971  0.343933   0.940141  0.081784","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"xs[2]\n# output\n4×4 Matrix{Float64}:\n 0.868892  0.697591  0.828991   0.475479\n 0.118892  0.947591  0.0789912  0.725479\n 0.368892  0.197591  0.328991   0.975479\n 0.618892  0.447591  0.578991   0.225479","category":"page"},{"location":"tutorial/#Binary-Functions-for-Digital-Sequences","page":"Tutorial","title":"Binary Functions for Digital Sequences","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For digital sequences, we sometimes want the binary representation of points. We can get the binary representations as integers and then convert them to their floating point values as follows ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"ds = DigitalSeqB2G(4)\nxb = NextBinary(ds,4)\n# output\n4×4 Matrix{UInt64}:\n 0x0000000000000000  0x0000000000000000  …  0x0000000000000000\n 0x0000000080000000  0x0000000080000000     0x0000000080000000\n 0x00000000c0000000  0x0000000040000000     0x0000000040000000\n 0x0000000040000000  0x00000000c0000000     0x00000000c0000000","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"BinaryToFloat64(xb,ds)\n# output\n4×4 Matrix{Float64}:\n 0.0   0.0   0.0   0.0\n 0.5   0.5   0.5   0.5\n 0.75  0.25  0.25  0.25\n 0.25  0.75  0.75  0.75","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This is also compatible with randomized digital sequences ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Reset!(ds)\nrds_single = RandomDigitalShift(ds,1,11)\nxb = NextBinary(rds_single,4)\n# output\n4×4 Matrix{UInt64}:\n 0x001293891708f524  0x0016da39893c2ad5  …  0x00167b863bac2dff\n 0x000293891708f524  0x0006da39893c2ad5     0x00067b863bac2dff\n 0x000a93891708f524  0x001eda39893c2ad5     0x001e7b863bac2dff\n 0x001a93891708f524  0x000eda39893c2ad5     0x000e7b863bac2dff","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"BinaryToFloat64(xb,rds_single)\n# output\n4×4 Matrix{Float64}:\n 0.58051    0.714139  0.862848  0.702579\n 0.0805097  0.214139  0.362848  0.202579\n 0.33051    0.964139  0.612848  0.952579\n 0.83051    0.464139  0.112848  0.452579","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Reset!(ds)\nrds_multiple = RandomDigitalShift(ds,2,11)\nxbs = NextRBinary(rds_multiple,4)\nxbs[1]\n# output\n4×4 Matrix{UInt64}:\n 0x001293891708f524  0x001b9c72840fa196  …  0x001d6f2b8e3bf612\n 0x000293891708f524  0x000b9c72840fa196     0x000d6f2b8e3bf612\n 0x000a93891708f524  0x00139c72840fa196     0x00156f2b8e3bf612\n 0x001a93891708f524  0x00039c72840fa196     0x00056f2b8e3bf612","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"xbs[2]\n# output\n4×4 Matrix{UInt64}:\n 0x0016da39893c2ad5  0x00167b863bac2dff  …  0x001cd7a908e348e1\n 0x0006da39893c2ad5  0x00067b863bac2dff     0x000cd7a908e348e1\n 0x000eda39893c2ad5  0x001e7b863bac2dff     0x0014d7a908e348e1\n 0x001eda39893c2ad5  0x000e7b863bac2dff     0x0004d7a908e348e1","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"BinaryToFloat64(xbs,rds_multiple)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Reset!(ds)\nNextBinary(RandomOwenScramble(ds,1,11),4)\n# output\n4×4 Matrix{UInt64}:\n 0x001a5eef4cd370c6  0x00028467570b42be  …  0x0001a6384b638476\n 0x000ff20fe5ead1ba  0x001cf89a1a9a2567     0x00151c3bba0d1d72\n 0x000691102ee5e771  0x0009fddc7fb98782     0x000b360939d54a00\n 0x001689e7a7bc5106  0x0014908fa8a77dff     0x001a7c08956e0175","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Getting binary points with linear ordering is also supported. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Reset!(ds) # resets rds_single and rds_multiple as well\nFirstLinearBinary(ds,2)\n# output\n4×4 Matrix{UInt64}:\n 0x0000000000000000  0x0000000000000000  …  0x0000000000000000\n 0x0000000080000000  0x0000000080000000     0x0000000080000000\n 0x0000000040000000  0x00000000c0000000     0x00000000c0000000\n 0x00000000c0000000  0x0000000040000000     0x0000000040000000","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"FirstLinearBinary(rds_single,2)\n# output\n4×4 Matrix{UInt64}:\n 0x001293891708f524  0x0016da39893c2ad5  …  0x00167b863bac2dff\n 0x000293891708f524  0x0006da39893c2ad5     0x00067b863bac2dff\n 0x001a93891708f524  0x000eda39893c2ad5     0x000e7b863bac2dff\n 0x000a93891708f524  0x001eda39893c2ad5     0x001e7b863bac2dff","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"xbs = FirstRLinearBinary(rds_multiple,2)\nxbs[1]\n# output\n4×4 Matrix{UInt64}:\n 0x001293891708f524  0x001b9c72840fa196  …  0x001d6f2b8e3bf612\n 0x000293891708f524  0x000b9c72840fa196     0x000d6f2b8e3bf612\n 0x001a93891708f524  0x00039c72840fa196     0x00056f2b8e3bf612\n 0x000a93891708f524  0x00139c72840fa196     0x00156f2b8e3bf612","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"xbs[2]\n# output\n4×4 Matrix{UInt64}:\n 0x0016da39893c2ad5  0x00167b863bac2dff  …  0x001cd7a908e348e1\n 0x0006da39893c2ad5  0x00067b863bac2dff     0x000cd7a908e348e1\n 0x001eda39893c2ad5  0x000e7b863bac2dff     0x0004d7a908e348e1\n 0x000eda39893c2ad5  0x001e7b863bac2dff     0x0014d7a908e348e1","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Reset!(ds)\nFirstLinearBinary(RandomOwenScramble(ds,1,11),2)\n# output\n4×4 Matrix{UInt64}:\n 0x001a5eef4cd370c6  0x00028467570b42be  …  0x0001a6384b638476\n 0x000ff20fe5ead1ba  0x001cf89a1a9a2567     0x00151c3bba0d1d72\n 0x001691102ee5e771  0x0011fddc7fb98782     0x001b360939d54a00\n 0x000689e7a7bc5106  0x000c908fa8a77dff     0x000a7c08956e0175","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"These may be converted to floats as before. ","category":"page"},{"location":"tutorial/#IID-Standard-Uniform-Generator","page":"Tutorial","title":"IID Standard Uniform Generator","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We provide an IID mathcalU01^s generator with the same API as lattice and digital sequences. This is a wrapper around Random.Xoshiro.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For reproducibility, you may provide a seed.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"iiduseq2 = IIDU01Seq(2,7)\nNext(iiduseq2,4)\n# output\n4×2 Matrix{Float64}:\n 0.0109452  0.488275\n 0.692198   0.579855\n 0.989369   0.242854\n 0.792208   0.983039","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Resetting the generator has expected syntax","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Reset!(iiduseq2)\nNext(iiduseq2,4)\n# output\n4×2 Matrix{Float64}:\n 0.0109452  0.488275\n 0.692198   0.579855\n 0.989369   0.242854\n 0.792208   0.983039","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Next(iiduseq2,4)\n# output\n4×2 Matrix{Float64}:\n 0.787362    0.529918\n 0.00539685  0.572203\n 0.183229    0.817671\n 0.200843    0.878721","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The generator is extensible in the number of points and dimension ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"iiduseq3 = IIDU01Seq(3,7)\nNext(iiduseq3,8)\n# output\n8×3 Matrix{Float64}:\n 0.0109452   0.488275  0.42079\n 0.692198    0.579855  0.128301\n 0.989369    0.242854  0.745755\n 0.792208    0.983039  0.90978\n 0.787362    0.529918  0.449277\n 0.00539685  0.572203  0.919712\n 0.183229    0.817671  0.880062\n 0.200843    0.878721  0.562207","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"As with other generators, a seed is not necessary","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"iiduseq = IIDU01Seq(3)\nsize(Next(iiduseq,4))\n# output\n(4, 3)","category":"page"},{"location":"tutorial/#Plotting","page":"Tutorial","title":"Plotting","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To save figures we need to ensure we are","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using CairoMakie","category":"page"},{"location":"tutorial/#Single-Projection","page":"Tutorial","title":"Single Projection","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"PLOTDIR = joinpath(@__DIR__,\"src/assets\")\nn = 2^6\nds = DigitalSeqB2G(3)\nfig = qmcscatter!(ds,n)\nsave(joinpath(PLOTDIR,\"basic.svg\"),fig)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: image)","category":"page"},{"location":"tutorial/#Extensibility","page":"Tutorial","title":"Extensibility","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"nvec = [1,2^6,2^7,2^8]\nfig = qmcscatter!(ds,nvec)\nsave(joinpath(PLOTDIR,\"extensibility.svg\"),fig)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: image)","category":"page"},{"location":"tutorial/#Multiple-Projections","page":"Tutorial","title":"Multiple Projections","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"dvec = [1 2; 1 3; 2 3]\nfig = qmcscatter!(ds,nvec,dvec)\nsave(joinpath(PLOTDIR,\"projections.svg\"),fig)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: image)","category":"page"},{"location":"tutorial/#Multiple-Randomizations","page":"Tutorial","title":"Multiple Randomizations","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"rds = RandomDigitalShift(DigitalSeqB2G(LinearMatrixScramble(3)),3)\nfig = qmcscatter!(rds,nvec,dvec)\nsave(joinpath(PLOTDIR,\"randomizations.svg\"),fig)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: image)","category":"page"},{"location":"tutorial/#Comparison-of-Sequences","page":"Tutorial","title":"Comparison of Sequences","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"iid = IIDU01Seq(3)\nrds_dslms = RandomDigitalShift(DigitalSeqB2G(LinearMatrixScramble(3)))\nrds_owen = RandomOwenScramble(DigitalSeqB2G(3))\nrls = RandomShift(LatticeSeqB2(3))\nfig = qmcscatter!([1,2^6,2^7,2^8],[1 2],iid=iid,rls=rls,rds_dslms=rds_dslms,rds_owen=rds_owen)\nsave(joinpath(PLOTDIR,\"seq_comparison.svg\"),fig)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: image)","category":"page"},{"location":"tutorial/#MC-vs-QMC","page":"Tutorial","title":"MC vs QMC","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We also need to be ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Distributions\nusing LinearAlgebra","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"m = 16\nr = 100\nseed = 7\nn = 2^m\ns,mu = 7,-11.05684907978818\nrseqs = [IIDU01Seq(s,seed),RandomShift(LatticeSeqB2(s),r,seed),RandomDigitalShift(DigitalSeqB2G(LinearMatrixScramble(s)),r,seed)]\nxsets = [\n    [Next(rseqs[1],n) for k=1:r],\n    NextR(rseqs[2],n),\n    NextR(rseqs[3],n)]\nf(x::Vector{Float64}) = π^(s/2)*cos(norm(quantile.(Normal(),x)/sqrt(2)));\nf(x::Matrix{Float64}) = map(i->f(x[i,:]),1:size(x,1))\nfig = Figure(resolution=(800,500))\nax = Axis(fig[2,1],\n    xlabel = L\"$n$\",\n    ylabel = L\"$| \\hat{\\mu} - \\mu |$\",\n    yscale = log10,\n    xscale = log2)\nxlims!(ax,[1,n])\nfor k=1:size(xsets,1)\n    name,xs = rseqs[k].name,xsets[k]\n    ys = vcat(map(i->f(xs[i]),1:r)'...)\n    muhats = cumsum(ys,dims=2); for i=1:r muhats[i,:] = muhats[i,:]./[i for i=1:n] end \n    err = abs.(muhats.-mu)\n    pows2 = 2 .^ (0:m)\n    qlowerr = map(p2->quantile(err[:,p2],.35),pows2)\n    qmid = map(p2->quantile(err[:,p2],.5),pows2)\n    qhigherr = map(p2->quantile(err[:,p2],.65),pows2)\n    lines!(ax,pows2,qmid,color=JULIA4LOGOCOLORS[k],label=name,linewidth=3)\n    band!(pows2,qhigherr,qlowerr,color=(JULIA4LOGOCOLORS[k],.3))\nend\nfig[1,1] = Legend(fig,ax,framevisible=false,orientation=:horizontal)\nhidespines!(ax, :t, :r)\nsave(joinpath(PLOTDIR,\"mc_vs_qmc.svg\"),fig)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: image)","category":"page"},{"location":"tutorial/#Logo","page":"Tutorial","title":"Logo","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"nvec = [1,4,16,64]\nrds = RandomOwenScramble(DigitalSeqB2G(2),1,17)\nx = Next(rds,maximum(nvec))\nfig = Figure(resolution=(500,500),backgroundcolor=:transparent)\nax = Axis(fig[1,1],aspect=1,xticklabelsvisible=false,yticklabelsvisible=false,backgroundcolor=:transparent)\nqmcscatter!(ax,x,nvec)\nlimits!(ax,[-0.01,1.01],[-0.01,1.01])\nfor i=1:7 vlines!(ax,i/8,color=JULIA4LOGOCOLORS[3],alpha=1); hlines!(ax,i/8,color=JULIA4LOGOCOLORS[3],alpha=1) end \nfor i=1:3 vlines!(ax,i/4,color=JULIA4LOGOCOLORS[2],alpha=1); hlines!(ax,i/4,color=JULIA4LOGOCOLORS[2],alpha=1) end \nfor i=1:1 vlines!(ax,i/2,color=JULIA4LOGOCOLORS[1],alpha=1); hlines!(ax,i/2,color=JULIA4LOGOCOLORS[1],alpha=1) end \nhidespines!(ax); hidedecorations!(ax); hidexdecorations!(ax,grid = false); hideydecorations!(ax, ticks = false)\nsave(joinpath(PLOTDIR,\"logo.svg\"),fig)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: image)","category":"page"}]
}
